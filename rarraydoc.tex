\documentclass[11pt,twoside]{article}
\usepackage{geometry,fancyhdr,hyperref,framed,charter,fullpage}
\setcounter{tocdepth}{1}
\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection\quad #1}}
\fancyhf{}
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries \hfill\rightmark\hfill}
\fancyhead[RE]{\hfill\bfseries\rightmark \hfill}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{15pt}
\fancypagestyle{plain}{\fancyhead{}\renewcommand{\headrulewidth}{0pt}}
\let\oldtt=\tt
%\renewcommand{\texttt}[1]{\color{blue}\tt #1\color{black}}
\newcommand{\cxx}{C{++}}

%\renewcommand{\texttt}[1]{#1}
\begin{document}

\setlength{\parskip}{1mm}

\title{\texttt{rarray}: Reference-Counted Multidimensional Arrays for \cxx}

\author{Ramses van Zon%\\
%\it\small SciNet High Performance Computing Consortium, University
%of Toronto, Toronto, Ontario, Canada
\vspace{-8pt}} 

\date{May, 2023 (version 2.5.1)\vspace{-7mm}}

\maketitle

\section{For the impatient: the what, why and how of rarray}

\noindent\textbf{What:}\\
Reference-counted and non-owning multidimensional arrays with runtime dimensions. 

\noindent\textbf{What not:}\\
No strides, no linear algebra, overloaded operators etc.

\noindent\textbf{Why:}\\
Usually faster than alternatives.\\
Uses the same accessors as automatic arrays.\\
Requires only the C++-11 standard.\\
Data is contiguous to allow interfacing with
libraries like BLAS, LAPACK, FFTW, etc.

\noindent\textbf{How:}\\
The header file \texttt{rarray} provides the type \texttt{rarray<T,R>}, where \texttt{T} is any type and {\tt R} is the rank. Element access uses repeated square brackets. Copying rarrays or passing them to functions mean shallow copies, unless explicitly asking for a deep copy. Streaming I/O is also part of the \texttt{rarray} header.

\

\centerline{\begin{tabular}{|l|l|}
\hline
\rule{0pt}{14pt}Define a \texttt{n$\times$m$\times$k} array of \texttt{float}s:&
\texttt{rarray<float,3> b(n,m,k);}
\\
\rule{0pt}{14pt}Define a \texttt{n$\times$m$\times$k} array of \texttt{float}s with&
\\
data pre-allocated at a pointer \texttt{ptr}:&
\texttt{rarray<float,3> c(ptr,n,m,k);}
\\
\rule{0pt}{14pt}Element i,j,k of the array \texttt{b}:&
\texttt{b[i][j][k]}
\\
\rule{0pt}{14pt}Pointer to the contiguous data in \texttt{b}:&
\texttt{b.data()}
\\
\rule{0pt}{14pt}Extent in the \texttt{i}th dimension in \texttt{b:}&
\texttt{b.extent(i)}
\\
\rule{0pt}{14pt}Shallow, reference-counted copy of the array:&
\texttt{rarray<float,3> d=b;}
\\
\rule{0pt}{14pt}Deep copy of the array:&
\texttt{rarray<float,3> e=b.copy();}
\\
\rule{0pt}{14pt}A rarray using an existing automatic array:&
\texttt{float f[10][20][8]=\{\dots\};}\\
&
\texttt{rarray<float,3> g=RARRAY(f);}
\\
\rule{0pt}{14pt}A rarray copy of an existing automatic array:&
\texttt{rarray<float,3> h=RARRAY(f).copy();}
\\
\rule{0pt}{14pt}Output a rarray to console:&
\texttt{std::cout << h << std::endl;}
\\
\rule{0pt}{14pt}Read a rarray from console:&
\texttt{std::cin >> h;}
\\\hline
\end{tabular}}


\newpage
\
\tableofcontents
\newpage
\section{Introduction}

While C and thus C++ has some support for multidimensional arrays
whose sizes are known at compile time, the support for arrays with
sizes that are known only at runtime, is limited. For one-dimensional
arrays,  C++ has a reasonable allocation and deallocation constructs in the operators
\texttt{new} and \texttt{delete} in the standard.  A standard way to allocate a
one-dimensional array is as follows:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
int n = 1000;
float* a;
a = new float[n];
a[40] = 2.4;
delete[] a;
\end{verbatim}%
\vspace{-12pt}\end{framed}\vspace{-5pt}\noindent%
It is important to note that this code also works if \texttt{n} was
not known yet at compile time, e.g., if it was passed as a function
argument or read in as input.

This style of allocation with a
``raw'' pointer is discouraged in C++ in favor of using ``smart''
pointers, which is possible since the C++17 standard:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
int n = 1000;
std::unique_ptr<float[]> a(new float[n]); 
a[40] = 2.4;
// a gets deallocated automatically, or one can explicitly call a.reset(nullptr)
\end{verbatim}%
\vspace{-12pt}\end{framed}\vspace{-5pt}\noindent%
A unique pointer \texttt{a} cannot be copied.  Instead of
\texttt{unique\_ptr} one can use \texttt{shared\_ptr}, which can be
copied and keeps a reference counter to know when to deallocate the
memory.  Automatic deallocation happens when \texttt{a} goes out of scope.

In the above code snippets, the \texttt{new} construct and the
\texttt{std::unique\_ptr/std::shared\_ptr} assign the address of the
array to a pointer. These pointers do not remember its size, so they are not really an 'array'.  The standard C++ library does provide a one-dimensional array that remembers its size, in the form of the \texttt{std::vector}, e.g.
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
int n = 1000;
std::vector a(n);
a[40] = 2.4;
// a gets automatically deallocated, or one can explicitly call a.clear()
\end{verbatim}%
\vspace{-12pt}\end{framed}\vspace{-5pt}%

Multi-dimensional runtime-allocated arrays are currently not supported yet by
\cxx (there is a proposal for a non-owning multidimensional array in
the C++23 standard).
The textbook \cxx\ solution for multidimensional arrays that are
dynamically allocated during runtime, is as follows:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  float*** a;
  a = new float**[dim0];
  for (int i=0;i<dim0;i++) {
    a[i] = new float*[dim1];
    for (int j=0;j<dim1;j++) 
      a[i][j] = new float[dim2];
  }
\end{verbatim}%
\vspace{-12pt}\end{framed}\vspace{-5pt}%
Apart from the fact this will soon be obsolute, drawbacks of this solution are:
\begin{itemize}
  \item the elements are not stored contiguously in memory, making
    this multi-dimensional array unusable
    for many numerical libraries,
  \item one has to keep track of array dimensions, and pass them along
    to functions,
  \item the intermediate pointers are non-const, so the
    internal pointer structure can be changed
    whereas, conceptually, \texttt{a} ought to be of type \texttt{float*const*const*}.
\end{itemize}
At first, there seems to be no shortage of libraries to fill this
lack of \cxx\ support for dynamic multi-dimensional arrays, such as
\begin{itemize}\itemsep 0pt \parskip 0pt
\item Blitz++;
\item The Boost Multidimensional Array Library (\texttt{boost::multiarray}); 
\item Eigen;
\item Armadillo; and
\item Nested \texttt{vector}s from the Standard Template Library.
\item Kokkos's reference implementation of the C++23 mdspan template.
\end{itemize}
These typically do have some runtime overhead compared to the above
textbook solution, or do not allow arbitrary ranks. In contrast, the purpose of the rarray
library is to be a minimal interface for runtime multidimensional
arrays of
arbitrary rank with
\emph{minimal to no performance overhead} compared to the textbook
solution.  For the above solutions, only the mdspan implementation in
Kokkos also has no overhead.

\noindent{\bf Example:\vspace{-7pt}}
\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  #include <rarray>
  int main() 
  {
     rtensor<float> a(256, 256, 256);
     a[1][2][3] = 105;
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}%
\end{framed}

\noindent{\bf Design Points of rarray}

\begin{enumerate}\itemsep1pt\parskip3pt
 
\item To have dynamically allocated multidimensional arrays that
combine the convenience of automatic c++ arrays while being compatible
with the
typical textbook-style dynamically allocated pointer-to-pointer
structure. 

The compatibility requirement with pointer-to-pointer structures
is achieved by allocating a pointer-to-pointer structure. This
structure accounts for most of the memory overhead from using \texttt{rarray}.

\item To be as fast as pointer-to-pointer structures.

\item To have rarrays know their sizes, so that they can be passed to
functions as a single argument. 

\item To enable interfacing with libraries such as BLAS and LAPACK: this
  is achieved by guarranteeing contiguous elements in the
  multi-dimensional array, and a way to get this data out.

  The guarrantee of contiguity means strided arrays are not supported.

\item To avoid dangling references (by utilizing reference counting).


\item To allow rarrays to hold non-owning views that use an existing buffer,
  without having to use a separate type.

\item To avoid some of the cluttered sematics around \texttt{const}
  correctness when converting to pointer-to-pointer structures when
  interfacing with legacy code.

\end{enumerate}

\noindent{\bf Features of rarray:\vspace{-3pt}}
\begin{itemize}\itemsep0pt\parskip2pt
\item Can use any data type {\tt T} and any rank {\tt R}.
\item Elements are accessible using repeated square brackets, like C/C++ arrays.
\item Views on pre-allocated contiguous arrays.
\item Does shallow, (atomic) reference counted, copies by default, but also has a deep {\tt copy}
  method.
\item Use of c++11 move semantics for efficiency (from version 2.0
  onwards, rarray requires c++11).
\item Can be emptied with the {\tt clear} method.
\item Can be filled with a uniform value with the {\tt fill} method.
\item Can be reshaped.
\item Automatic C-style arrays can be converted to rarrays using {\tt
  RARRAY}.
\item Checks index bounds if the preprocessor constant {\tt RA\_BOUNDSCHECK} is defined. 
\item A method {\tt empty} to check if the rarray is uninitialized.
\item A method to get the number of elements in each
  dimension (\texttt{extent}), or in all dimensions (\texttt{shape}).
\item A method to obtain the total number of elements in the
  array (\texttt{size}).
\item A method to make the data type of the array const
  (\texttt{const\_ref}).
\item Conversion methods using the member
  function \texttt{data()} for conversions to a \texttt{T*} or
  \texttt{const T*}, using the method \texttt{ptr\_array()} for
  conversions to \texttt{T*const*} or \texttt{const T*const*}, and
  using the method \texttt{noconst\_ptr\_array()} for the conversion to a
  \texttt{T**}.
\item Streaming input and output.
\end{itemize}

\section{Using rarrays}

\subsection{Defining a multidimensional rarray}
\label{definerarray}

To use \texttt{rarray}, first include the header file:
\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  #include <rarray>
\end{verbatim}%
\vspace{-14pt}
\end{framed}
\noindent
This defines the (template) classes \texttt{rarray{\tt<}T,R{\tt>}}, where
\texttt T is the element type, and \texttt R is the
rank (a positive integer).  Instances can now be
declared as follows:
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  rarray<float,3> s(256,256,256);
  s[1][2][3] = 105;
  // do whatever you need with s
\end{verbatim}%
\vspace{-14pt}
\end{framed}
\noindent
or, using an external, pre-allocated buffer, as
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  std::unique_ptr<float> pre_alloc_data(new float[256*256*256]); 
  rarray<float,3> s(pre_alloc_data,256,256,256);
  s[1][2][3] = 105;
  // do whatever you need with s
  s.clear(); // optional explicit deallocation
  pre_alloc_data.reset(nullptr); // optional explicit deallocation
\end{verbatim}%
\vspace{-14pt}
\end{framed}
Note that \texttt{s} will have dangling references (often leading to
``Segmentation faults'') if pre\_alloc\_data is deallocated while s is
not.  This reflects that rarray is in this case not responsible
for the content. The data pointer can also be retrieved using
\texttt{s.data()}. The \texttt{s.clear()} statement ensures there are
no dangling references to this data left in \texttt{s}. 

In the former case (\texttt{rarray<float,3> s(256,256,256)}), calling
\texttt{s.clear()} before the rarray goes out of scope would
release the memory of this array.

The construction specifying a number of extents as arguments works for arrays with rank up to and including 11. For arrays with larger rank, you have to pass an pointer to the array of extents.

\subsection{Shorthand rarray types: rvector, rmatrix, rtensor}

For convenience, rarray defines shortcut types for
one-dimensional, two dimensional and three dimensional arrays, called
rvector, rmatrix and rtensor, respectively. The following equivalences hold:

\begin{framed}\vspace{-18pt}%
\begin{verbatim}
rvector<T> = rarray<T,1>
rmatrix<T> = rarray<T,2>
rtensor<T> = rarray<T,3>
\end{verbatim}
\vspace{-18pt}\end{framed}\noindent
for any type \texttt{T}.

\subsection{Accessing elements of an rarray}

The elements of rarray objects are accessed using the repeated square
bracket notation as for automatic \cxx\ arrays. Thus, if \texttt{s} is a \texttt{rarray} of rank \texttt R, the elements are accessed using \texttt{R} times an index of the form \texttt{[n$_i$]}, i.e. \texttt{s[n$_0$][n$_1$]\dots[n$_{\texttt{R}-1}$]}
For example:\vspace{-9pt}
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  for (int i=0;i<s.extent(0);i++)
    for (int j=0;j<s.extent(1);j++)
      for (int k=0;k<s.extent(2);k++)
        s[i][j][k] = i+j+k;
\end{verbatim}%
\vspace{-12pt}
\end{framed}%\vspace{-8pt}\noindent

In addition to the explicit assignment of each element, there is an
alternative way to assign values to the elements of an rarray using a
comma separate form, as follows
\vspace{-9pt}
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  rarray<double,2> matrix(3,3);
  matrix = 1,2,3,
           4,5,6,
           7,8,9;
\end{verbatim}%
\vspace{-12pt}
\end{framed}\vspace{-8pt}\noindent
This is usefully mostly for small matrices (as in tests), as entering
large rarrays in this way is rather impractical.

\subsection{Copying and function arguments}

In C++, when we copy a variable of a built-in type to a new variable,
the new copy is completely independent of the old variable. Likewise,
the default way of passing arguments to a function involves a complete
copy for built-in types.  For C-style arrays, however, only the
pointer to the first element gets copied, not the whole array. The
latter is called a shallow copy. Rarrays use shallow copies much like
pointers, but uses atomic reference counting to know when memory can
be released (similar to the \texttt{std::shared\_ptr<T>} of C++11 and
\texttt{std::shared\_ptr<T[]>} of C++14). 

What does this essentially mean? Well:
\begin{enumerate}
\item You can pass rarrays by value to function, which is as if you
  were passing a pointer.\linebreak (Passing by reference also works.)
\item When you assign one rarray to another, the other simply points to the old one.
\item If you wish to do a deep copy, i.e., create a new array independent of the old array, you need to use the \texttt{copy} method.
\end{enumerate}

\subsection{Returning a rarray from a function\label{returnvalues}}

Because rarray uses atomic reference counting and implements move semantics, returning an rarray from a
function poses no problems.

Consider the function \texttt{zeros} used in \texttt{main()}:
\vspace{-9pt}
\begin{framed}\vspace{-12pt}%
%TEST THIS
\begin{verbatim}
#include <rarray>
rarray<double,2> zeros(int n, int m) {
   rarray<double,2> r(n,m);
   r.fill(0.0);
   return r;
}
int main() {
   rarray<double,2> s = zeros(100,100);
   return s[99][99];
}
\end{verbatim}%
%END TEST THIS
\vspace{-12pt}
\end{framed}\vspace{-8pt}
In line 2, a rarray \texttt{r} is created, and filled, on line 3, with
zeros. On line 4, \texttt{r} gets moved out of
the function and into \texttt{s}, using C++11's move
semantics. Move semantics cause \texttt{r} to be left in an empty state
that will not deallocate the memory associated with the array \texttt{s}.

\subsection{Reshaping the rarray}

To use the data in an rarray but access it in a different `shape', one can
\begin{enumerate}
  \item create a new rarray which uses the data from the first rarray. E.g.
\vspace{-9pt}
\begin{framed}\vspace{-3pt}%
\begin{verbatim}
void dump(const rarray<double,3>& r) {
   rarray<double,1> rflat(r.data(), r.size());
   for (int i=0;i<r.size();i++)
       std::cout << rflat[i] << ' ';
   std::cout << std::endl;
}
\end{verbatim}%
\vspace{-12pt}
\end{framed}\vspace{-8pt}
\item or one can reshape the existing rarray with the desired
  dimensions. E.g.
\vspace{-2pt}
\begin{framed}\vspace{-4pt}%
\begin{verbatim}
void dump(rarray<double,3> r) {
   r.reshape(1, 1, r.size());
   for (int i=0;i<r.size();i++)
       std::cout << r[0][0][i] << ' ';
  std::cout << std::endl;
}
\end{verbatim}%
\vspace{-12pt}
\end{framed}\vspace{-8pt}
\end{enumerate}
The latter only works if the new and old shape have the same ranks and
the number of elements stays the same. It is possible to reshape an
rarray to have less elements, but only by explicitly passing a last
parameter \texttt{ra::RESIZE::ALLOWED}, e.g.
\begin{framed}\vspace{-4pt}%
\begin{verbatim}
void dump(rarray<double,3> r) {
   r.reshape(1, 1, r.size()/2, ra::RESIZE::ALLOWED);
   for (int i=0;i<r.size();i++)
       std::cout << r[0][0][i] << ' ';
  std::cout << std::endl;
}
\end{verbatim}%
\vspace{-12pt}
\end{framed}\vspace{-8pt}
\noindent It should be stressed that the last example has no side effects for
the shape of the original rarray that was passed to the function,
because the rarray was passed by value, which implies a shallow copy;
the original array retains its shape. It the array was passed by
reference, the original array would of course be changed.

It is never possible to do a reshape that leads to more elements,
because, by design, the reshape method should not allocated any
memory.


\subsection{Optional bounds checking}

If the preprocessor constant \texttt{{\tt RA\_BOUNDSCHECK}} is defined, an
\texttt{out\_of\_bounds} exception is thrown~if
\begin{itemize}\itemsep0pt\parskip3pt
\item an index is too small or too large;
\item the size of dimension is requested that does not exist (in a call to \texttt{extent(int i)});
\item a constructor is called with a zero pointer for the buffer or for the dimensions array;
\end{itemize}
\texttt{{\tt RA\_BOUNDSCHECK}} can be defined by
adding the {\tt -DRA\_BOUNDSCHECK} argument to the compilation command, or
by \texttt{{\tt\#define RA\_BOUNDSCHECK}} before
the \texttt{{\tt\#include <rarray>}} in the source.

%\pagebreak

\section{Comparison with standard alternatives}

Compared to the old textbook method of declaring an array (see above), or the rarray method:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
#include <rarray>
int main() {
  int n = 256;
  rarray<float,3> arr(n,n,n); 
  arr[1][2][3] = 105;
}
\end{verbatim}
\vspace{-14pt}\end{framed}
\noindent
the more-or-less equivalent automatic array version 
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
int main() {
  int n = 256;
  float arr[n][n][n]; 
  arr[1][2][3] = 105;
}
\end{verbatim}
\vspace{-14pt}\end{framed}
\noindent
is a little simpler, but automatic arrays are allocated on the stack,
which is typically of limited size. Another big drawback is that this array cannot be passed to functions that do
not hard-code exact matching dimensions except for the last
one.

Using rarray also has benefits over another common \cxx\ 
solution, i.e. using the Standard Template Library:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  #include <vector>
  int main() {
     using std::vector;
     int n = 256;                // size per dimension
     vector<vector<vector<float>>> v(n);// allocate for top dimension
     for (int i=0;i<n;i++) {
        v[i].resize(n);         // allocate vectors for middle dimension
        for (int j=0;j<n;j++) 
           v[i][j].resize(n);   // allocate elements in last dimension
     }
     v[1][2][3] = 105;           // assign to element (for example)
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}\end{framed}\vspace{-8pt}
\noindent
which is complicated, is non-contiguous in memory, and likely
slower.

C++23 will have a non-owning library, mdspan, which should work
roughly as follows:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  #include <memory>
  #include <mdspan>
  int main() {
     int n = 256;                  // size per dimension
     std::unique_ptr<float[]> p (new float[n*n*n]); // or vector or a shared_ptr
     using exts =  std::extents<size_t,std::dynamic_extent,
                   std::dynamic_extent,std::dynamic_extent>;
     std::mdspan<float,exts> (vector.data(), exts(n,n,n));
     v[1,2,3] = 105;               // assign to element (for example)
  }
\end{verbatim}%
\vspace{-14pt}\end{framed}\vspace{-8pt}
This example declares all types explicitly, but C++17 has a lot of
deduction capabilities, which would also allow this to be a bit more brief. 


\pagebreak[4]
\section{Class definition}

\subsection{Interface}
Effectively, the interface part of a rarray object is defined as follows:%
\vspace{-8pt}%
\begin{framed}\vspace{-14pt}%
\begin{verbatim}
template<typename T, int R>
class rarray {
public:    
 rarray();                                 // create uninitialized array
 rarray(size_type extent0, ...);           // constructor for R<=11
 rarray(const size_type* extents);         // alternative: extents in array
 rarray(T* data, size_type extent0, ...);  // construct with existing data
 rarray(T* data, const size_type* extents);// alternative: extents in array
 rarray(const rarray<T,R> &a);             // shallow copy constructor   
 ~rarray();                                // destructor 
 void reshape(size_type extent0, ...);     // change copy's shape (not data)
 void reshape(const int* size_type);       // change copy's  shape (not data)
 void clear();                             // release memory
 void fill(const T& value);                // fill with uniform value
 bool empty() const;                       // check if uninitialized;
 rarray<T,R> copy() const;                 // deep copy
 const size_type*  shape() const;          // all extents as C-style array
 size_type extent(int i) const;            // extent in dimension i
 size_type size() const;                   // total number of elements
 T* data() const;                          // start of internal buffer
 T*const*... ptr_array() const;            // convert to a T*const*... 
 T**... noconst_ptr_array() const;         // converts to a T**... 
 rarray<const T,R>&  const_ref() const;    // convert to const elements
 rarray<T,R>& operator=(const rarray<T,R> &a);// shallow assignment
 operator[](size_t i) const;      // enables const element access
 operator[](size_t i);            // enables element access for assignment
 rarray<T,R-1> at(size_t i);      // retrieve the ith 'row' with bounds checking
};
\end{verbatim}
\end{framed}



\subsection{Methods}

%\subsubsection{Get size in each dimension: \tt extent}
\noindent\textbf{Definition:} \texttt{int extent(int i) const;}

This method returns the size of dimension \texttt{i}.

%\subsubsection{Get size in each dimension: \tt extent}
\noindent\textbf{Definition:} \texttt{const int* shape() const;}

This method returns the size of all dimensions as a c array. 

%\subsubsection{Get total size: \tt size}
\noindent\textbf{Definition:} \texttt{int size() const;}

This method returns the total number of elements.

%\subsubsection{Get pointer equivalent: \tt data}

\noindent\textbf{Definition:} \texttt{T* data() const;}

This method returns a pointer to the first element of the array.

%\subsubsection{Get pointer equivalent: \tt ptr\_array}

\noindent\textbf{Definition:} \texttt{T*const*... ptr\_array() const;}

This method returns a pointer to a \texttt{T*const*...}.  Note that
rarrays have an automatic conversion to this type.

%\subsubsection{Get const-casted pointer equivalent: \tt noconst_ptr\_array}

\noindent\textbf{Definition:} \texttt{T**... noconst\_ptr\_array() const;}

This method returns a pointer to a \texttt{T**...}. (This conversion breaks const-correctness.)

%\subsubsection{Get const-content equivalent: \tt const\_ref}

\noindent\textbf{Definition:} \texttt{rarray{\tt<}const T,R{\tt>}\& const\_ref() const;}

This method creates reference to this with const elements.

\noindent\textbf{Definition:} \texttt{void reshape(int extent0, ...);}

This method can be used to change the shape of the rarray. The data in
the underlying buffer will not change. Note that the number of
dimensions (i.e., the rank) must remain the same and the total new size must be less or equal to the old size.  This works only for arrays with rank up to and including 11. 

\noindent\textbf{Definition:} \texttt{void reshape(const int* extents);}

Same as the previous \texttt{reshape} method, but takes an array of new dimensions as an argument.  This is the only way to reshape an array of rank twelve or higher.

\noindent\textbf{Definition:} \texttt{void clear();}

This method release memory the memory associated with the rarray. If the rarray was created by providing a pre-existing buffer for the data, the memory of this buffer does not released.

\noindent\textbf{Definition:} \texttt{void fill(const T\& value);}

This method fills the array with a uniform value \texttt{value}.

\noindent\textbf{Definition:} \texttt{bool empty();}

Checks if the rarray is in an uninitialized state.

\noindent\textbf{Definition:} \texttt{rarray{\tt<}T,R{\tt>} copy() const;}

This method creates deep copy of the rarray, i.e., an independent rarray with the same dimensions are the original rarray and with its content a copy of the original rarray's content.

\section{I/O}

\subsection{Streaming input and output}

Although it is usually preferrable to store large arrays in binary, rarray does provide streaming operators \texttt{<<} and \texttt{>>} to read and write to standard C++ iostreams.  

The output produced by the output streaming operator is like that of
automatic arrays initializers: Each dimension is started and ended by
\texttt{\{} and \texttt{\}} and components are comma separated.
Except for the inner dimension, newlines are included in the output,
but no spaces, and no trailing newline.
E.g.:\vspace{-9pt}
\begin{framed}\vspace{-18pt}%
%TEST THIS
\begin{verbatim}
  #include <iostream>
  #include <rarray>
  int main() {
    int buf[6] = {1,2,3,4,5,6};
    rarray<int,2> arr(buf,3,2);
    std::cout << arr;
  }
\end{verbatim}%
%END TEST THIS
\vspace{-12pt}
\end{framed}\vspace{-8pt}\noindent
will print the following:
\begin{verbatim}
{
{1,2},
{3,4},
{5,6}
}
\end{verbatim}
Apart from inserting curly braces, commas, and newlines, the streaming
operators use the streaming operators of the element types. 

The streaming operators are designed such that the format that is
written out by the \texttt{<<} operator, should be readable by the
\texttt{>>} operator.  
Without further formatting rules, reading would not be unambiguous for
some types, e.g. for
\texttt{std::string}, that can contain the syntactic elements
`\texttt{\{}', `\texttt{\}}', `\texttt{,}', or `\texttt{\#}'.  If these elements are found in the output of an element, the element is prepended with a string that encodes the string length of the output. This prepending string starts with a '\texttt\#' character, then the length of the string output for the element  (excluding the prepended part), followed by a `\texttt:' character.

An exception to the '\texttt\#' formatting rule exists for types that
stream out such that the first output character is '\texttt(' and the
last is '\texttt)', with no other '\texttt)' characters
intervening. Such output does not require the '\texttt\#'
formatting. Complex numbers are a prime example of a type with such
output and input.

Note that while the input stream operators expect the same format as
the output produces by the output streams, they but will
not care if newlines are not there. However, there should not be any extraneous
whitespace in the input.

\section{Utilities: xrange and linspace}

The rarray library contains a few more utilities.

\subsection{xrange}

The xrange function returns an iterable generator, which can produce
numbers from a starting point, with some step size, up to but not
including an end point.  In the simplest case, this can be used as a
counter, e.g.:
\begin{verbatim}
  #include <iostream>
  #include <rarray>
  int main() {
    for (int i: xrange(1000))
      std::cout << i << " ";
    std::cout << std::endl;
  }
\end{verbatim}
will print the numbers 0 to 999, which are generated in succession,
i.e., no integer array of size 1000 containing these numbers is ever
created. The return type of the xrange function is an
\texttt{ra::Xrange<T>} object, with \texttt{T} equal to \texttt{int}
in the above example.  This is an iterable object that can be used in
a range-based for.  It could also be used as the source of a copy, and
thus to initialize an rarray, e.g. you could get an array with values
\texttt{0,2,4,...,998}, as follows
\begin{verbatim}
  #include <rarray>
  #include <algorithm>
  int main() {
    ra::Xrange<int> in = xrange(0,1000,2);
    rvector<int> r(500);
    std::copy(in.begin(), in.end(), r.begin());
    ...
  }
\end{verbatim}
(replacing the type \texttt{ra::Xrange<int>} with c++11's
\texttt{auto} seems like a good idea here).

The general form of the range function is
\begin{verbatim}
ra::Xrange<T> xrange(T endvalue)
ra::Xrange<T> xrange(T beginvalue, T endvalue, T stepsize=1)
\end{verbatim}
In the first form, the begin value is 0 and the stepsize is 1. These
are template functions, where T can be any time that can be converted
to a double, although the most useful cases are those where T is an
integer.  In all cases, the first generated value is exactly
\texttt{beginvalue}, each subsequent value is one stepsize larger, and
the endvalue is the first value that is not generated (to be precise,
the number of numbers generated is
\texttt{ceil(beginvalue-endvalue)/stepsize)}, using floating point
division).

The case where \texttt{endvalue} is less than \texttt{beginvalue}, or
for which \texttt{stepsize} is negative, are, in the current rarray
version, 2.1, undefined.

\subsection{linspace}

The \texttt{linspace} function returns a rvector with a specified
number of points between two given values, inclusively.  The general
form of the function is
\begin{verbatim}
rvector<T> linspace(T x1, T x2, int n, bool end_incl=true);
\end{verbatim}
Here, \texttt{x1} is the (guarranteed) first value, \texttt{x2} the
(guarranteed) last value, and \texttt{n} is the number of values.  If
the latter is not given or is set to zero, the number of values is
such that the stepsize is as close to one as possible. If
\texttt{end\_incl} is set to false, the generated values are such as if
the number of point is \texttt{n+1} but the last value is omitted.

For example, to create an \texttt{rvector} with 101 equally spaced
values between $-1.0$ and $1.0$, one would do
\begin{verbatim}
  #include <rarray>
  int main() {
    rvector<double> r = linspace(-1.0, 1.0, 101);
    ...
  }
\end{verbatim}

The first argument of linspace is allowed to be greater than the last,
in which case, decreasing values are generated.  The two arguments are
allowed to be equal as well, which generates a vector with all equal values. In that case, \texttt{end\_incl} can not
be set to false. The case where the number of points is 1 and
\texttt{end\_incl=false} is ill defined.

Note that for integer types, using linspace without specifying their
number (i.e. \texttt{linspace(n1,n2)}) gives the same values as are
generated by the xrange function without a stepsize and with the
endvalue one higher (i.e., \texttt{xrange(n1,n2+1)}).


\section{Performance}

\subsection{General performance consideration}

\noindent
\texttt{rarray} is written specifically with performance in
mind. However, the way it manages to mimic the natural c and c++ way
of using multi-dimensional arrays, i.e. with (repeated) square
brackets, would come at a high cost of function calls and temporary
objects. The rarray library tries to inline most function calls to avoid this
cost, but it needs the c++ compiler's optimization capabilities to
help out. Even the lowest optimization levels, such as obtained with
the \texttt{-O1} flag, will enable this.

Rarray is meant to be used with higher levels of optimization. When
compiled with higher optimization levels, such as \texttt{-O3
  -fstrict-aliasing} for \texttt{g++}, inlining should make the rarray
objects at least as fast as the textbook solution for multidimensional
arrays mentioned in the introduction.

\subsection{Debugging}

When debugging a code with a symbolic debugger (e.g. gdb), in addition
to compiling with an option to include symbols\footnote{Names of
  functions and other information regarding the code such as line
  numbers and file names are collectively called ``symbols''.} into
the executatble (e.g. \texttt{-g}), one usually switches off the
compiler's optimization capabilities (\texttt{-O0}), because it can
change the order of instructions in the code, which makes debugging
very difficult. As explained above, when working with rarray, turning
of the compiler's optimization options, can cause the program to
become quite a bit slower, which can also hamper debugging.  If the
bug is unlikely to occur in rarray, it may be worth trying build with
a mild optimization level such as \texttt{-O1} for debugging.

If, on the other hand, the bug is in rarray, one likely needs to
switch off optimization to see what is going on.  In addition to the
\texttt{-O0} flag, this also requires switching off forced inlining,
using the \texttt{-DRA\_INLINE=inline} flag.

\subsection{Profiling}

Sampling profiling tools (such as \texttt{gprof}) work by periodically
recording the state and call stack of the program as it runs.  They
can be very useful for performance analysis. When using these tools
with rarray, it is advisable to compile with a minimum level of
optimization \texttt{-O1}. Otherwise, a lot of the internal function
calls of rarray that could simply be optimized away, and would pollute
the sampling. 

\subsection{Memory overhead using the rarray class}

The memory overhead here comes from having to store the dimensions and a pointer-to-pointer structure.  The latter account for most of the memory overhead.   A rarray object of 100$\times$100$\times$100$\times$100  doubles on a 64-bit machine will have a memory overhead of a bit over 1\%. In general, the memory overhead as a percentage is roughly 100\% divided by the last dimension. Therefore, avoid rarrays with a small last dimension such as 100$\times$100$\times$100$\times$2.

\subsection{Compilation overhead using the rarray class}

There is an overhead in the compilation stage, but this is very compiler dependent.

\section{Working with libraries}
\label{libraries}

Performance was one reason for writing the rarray library.  Being able
to pass such arrays to numerical libraries was another.

Many numerical libraries, such as BLAS, LAPACK and FFTW, are C or
fortran based and their API requires that
\begin{enumerate}
\item the array elements are stored contiguously in memory,
\item one passes the pointer to the first element, and
\item one passes the dimensions of the array explicitly.
\end{enumerate}
Rarray helps in satisfying these requirement as follows:
\begin{enumerate}
\item Elements of a rarray are always stored contiguously in memory.
\item The pointer to the first elements of the array can be found with
  the member function \texttt{data()}.
\item The dimensions of the arrays can be found from
    the \texttt{extent} or \texttt{shape} member functions of rarray (or, for
    one-dimensional arrays, also with the \texttt{size} member function).
\end{enumerate}

Here is an example to call the matrix-matrix multiplication routine
from blas, using the cblas interface:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TET THIS
\begin{verbatim}
  #include <iostream>
  #include <rarray>
  #include <cblas.h>
  int main() {
     int m=2, k=3, n=4;
     rmatrix<double> a(m,k), b(k,n), c(m,n);
     a = 1,-2,3,
         2,-1,0;
     b = -1,3,-2,1,
         -2,1,-3,2,
         -3,2,-1,3;
     cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                 c.extent(0), c.extent(1), a.extent(1), 1.0,
                 a.data(), a.extent(1),
                 b.data(), b.extent(1),
                 1.0,
                 c.data(), c.extent(1));
     std::cout << "a=" << a << '\n'
               << "a=" << b << '\n' 
               << "c=a*b=" << c << '\n';
  }
\end{verbatim}%
%END TET THIS
\vspace{-14pt}\end{framed}\vspace{-8pt}
\noindent
See the blas documentation, for the precise meaning and operation of
(c)blas.

Especially when working with complex data, an extra conversion may be
required. For instance, working with the library called FFTW3, the
following is a way to compute the fourier transform of a complex
rarray:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TET THIS
\begin{verbatim}
  #include <iostream>
  #include <complex>
  #include <rarray>
  #include <fftw3.h>
  int main() {
     int n = 4;
     rvector<std::complex<double>> a(n), b(n);
     a = 1.3+5.0i, 1.0, 5.0i, 2.0-5.0i;
     fftw_plan plan = fftw_plan_dft_1d(a.size(),
                        (fftw_complex*)a.data(), (fftw_complex*)b.data(), 
                        FFTW_FORWARD, FFTW_ESTIMATE);
     fftw_execute(plan);
     fftw_destroy_plan(plan);
     std::cout << "a=" << a << '\n' << "FT(a)=" << b << '\n';
  }
\end{verbatim}%
%END TET THIS
\vspace{-14pt}\end{framed}\vspace{-8pt}
\noindent
Note that this example uses the concise c++14 notation for complex
variables (compile with \texttt{-std=c++14} or equivalent). Again, for the precise meaning of the fftw function call, see the documentation of
that library.

Finally, it is worth noting that many numerical libraries care about
the ``alignment'' of the data.  Rarray currently does not have any way of
facilitating alignment, but a user can allocate aligned
data and pass it as a pre-existing buffer to the rarray constructor
(see \ref{definerarray}).

\section{Conversions}

\subsection{Converting automatic C-style arrays to rarrays}

It is possible to convert C-style automatic arrays to rarrays using the {\tt RARRAY} macro (which calls some templated functions under the hood).  You can apply {\tt RARRAY} to any automatic array of rank six or less. 
The main convenience of this is that one can write functions that take rarray argument(s) and pass automatic arrays to them. Another use is in initializing a rarray. For example:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
#include <iostream>
#include <rarray>
void print2d(const rarray<float,2> &s) {
    for (int i=0; i<s.extent(0); i++) {
        for (int j=0; j<s.extent(1); j++)
            std::cout << s[i][j] << ' ';
        std::cout << std::endl;
    }
}
int main() {
    float printme[4][4] = { { 1.0, 1.2, 1.4, 1.6},
                            { 2.0, 2.2, 2.4, 2.6},
                            { 3.0, 3.2, 3.4, 3.6},
                            { 4.0, 4.2, 4.4, 4.6} };
    print2d(RARRAY(printme));
    rarray<float,2> a = RARRAY(printme).copy();
    print2d(a);
}
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}\end{framed}\vspace{-8pt}



\subsection{Conversions for function arguments}

A function might take a \texttt{rarray{\tt<}const T,R{\tt>}} parameter if elements are not changed by it. Because \cxx\ cannot convert a reference to a \texttt{rarray{\tt<}T,R{\tt>}} to a \texttt{rarray{\tt<}const T,R{\tt>}}, one has to use the \texttt{const\_ref} method to do this for you.
For example:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  float add(const rarray<const float,2> &s)   {
     float x = 0.0;
     for (int i=0; i<s.extent(0); i++)
        for (int j=0; j<s.extent(1); j++)
           x += s[i][j];
     return x;
  }
  int main() {
     rarray<float,2> s(40, 40);
     float z = add(s.const_ref()); // because add() takes <const float>
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}
\end{framed}\vspace{-8pt}

rarray objects are also easy to pass to functions that do not use \texttt{rarray}s. Because there are, by design, no automatic conversions of a
rarray, this is done using methods.

There are two main ways that such functions expect a multidimensional
array to be passed: either as a pointer (a \texttt{T*}) to the first
element of the internal buffer composed of all elements, or as a
pointer-to-pointer structure (a \texttt{T**...}).  In the former case, it may be
important to know that a rarray stores elements in row-major
format.

With the \texttt{const} keyword, the number of useful \cxx\ forms for multidimensional array arguments has grown to about six.  In the case of a two-dimensional array these take the forms:
 \texttt{T*}, \texttt{const T*}, \texttt{T*const*}, \texttt{const T*const*}, \texttt{T**}, and \texttt{const T**}.
Using the rarray library, const-correct argument passing requires the \texttt{data} or \texttt{ptr\_array} method but non-const-correct argument passing will require the \texttt{noconst\_ptr\_array} function, possibly combined with \texttt{const\_ref}.
We will briefly looking at these cases separately now.

\subsection{Conversion to a {\tt T*} or a {\tt const T*}}

A function may expect a multidimensional array to be passed as a
simple pointer to the first element, of the form \texttt{T*}, or of
the form  \texttt{const T*}. This is the case for most c or fortran
libraries, as disussed above in \ref{libraries}. A rarray object
\texttt{s} of type \texttt{rarray{\tt<}T,I{\tt>}} can be passed to these
functions using the syntax \texttt{s.data()}, which yields a
\texttt{T*}.

\noindent{\bf Example 1:}
\begin{framed}\vspace{-15pt}%
%TEST THIS
\begin{verbatim}
  void fill1(float* a, int n1, int n2, float z) {
     for (int i=0; i<n1*n2; i++)
       a[i] = z;
  }
  int main() {
     rarray<float,2> s(40, 40);
     fill1(s.data(), s.extent(0), s.extent(1), 3.14);
  }
\end{verbatim}%
%END TEST THIS
\end{framed}

\pagebreak[3]

\noindent{\bf Example 2:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  float add2(const float* a, int n1, int n2) {
     float x = 0.0;
     for (int i=0; i<n1*n2; i++)
         x += a[i];
     return x;
  }
  int main() {
     rarray<float,2> s(40, 40);
     float z = add2(s.data(), s.extent(0), s.extent(1));
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}\end{framed}\vspace{-8pt}

\noindent
C++ accepts a \texttt{float*} instead of a \texttt{const float*}, so \texttt{data()} can be used in the latter example.

\subsection{Conversion to a {\tt T*const*} or a {\tt const T*const*} }

\noindent
In \texttt{T*const*}, the middle const means that one cannot reassign
the row pointers. 
The rarray classes can be converted to this type using the
\texttt{ptr\_array()} method, but rarrays  also an automatic
conversion to this type.
For higher dimensions, this case generalizes to \texttt{T*const*const*}, \texttt{T*const*const*const*}, etc.

\noindent
{\bf Example 1:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  void fill3(float*const* a, int n1, int n2, float z) {
     for (int i=0; i<n1; i++)
        for (int j=0; j<n2; j++)
           a[i][j] = z;
  }
  int main() {
     rarray<float,2> s(40, 40);
     fill3(s.ptr_array(), s.extent(0), s.extent(1), 3.14);
     // or, since rarray 2.0:
     fill3(s, s.extent(0), s.extent(1), 3.14);
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}\end{framed}\vspace{-8pt}

\noindent
{\bf Example 2:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  float add4(const float*const* a, int n1, int n2) {
     float x = 0.0;
     for (int i=0; i<n1; i++)
        for (int j=0; j<n2; j++)
           x += a[i][j];
     return x;
  }
  int main() {
     rarray<float,2> s(40, 40);
     float z = add4(s.ptr_array(), 40, 40);
     // or,, since rarray 2.0,  z = add4(s, 40, 40);
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}
\end{framed}

\noindent
\cxx\ accepts a \texttt{T*const*} where a \texttt{const T*const*} is expected, so here one can again use the method \texttt{ptr\_array()}.
This extends to its generalizations \texttt{const T*const*const*},\linebreak \texttt{const T*const*const*const*}, etc., as well.


\subsection{Conversion to a {\tt T**}}

\noindent
Generating a T** from a rarray object, one could change the internal structure of that rarray object through the double pointer.  This is therefore considered a not const-correct.  It is however commonly needed, so \texttt{rarray} does have a function for it, called \texttt{noconst\_ptr\_array}. 

\noindent
{\bf Example:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  void fill5(float** a, int n1, int n2, float z) {
     for (int i=0; i<n1; i++)
        for (int j=0; j<n2; j++)
           a[i][j] = z;
  }
  int main() {
     rarray<float,2> s(40, 40);
     fill5(s.noconst_ptr_array(), s.extent(0), s.extent(1), 3.14);
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}
\end{framed}

\subsection{Conversion to a {\tt const T**}}
\noindent
C++ does not allow conversion from T** to \texttt{const T**}. To convert to a \texttt{const T**}, one first needs to convert the \texttt{rarray{\tt<}T,R{\tt>}} to a \texttt{rarray{\tt<}const T,R{\tt>}} using \texttt{const\_ref()}, after which one can use the \texttt{noconst\_ptr\_array} function.

\noindent
{\bf Example:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  float add6(const float** a, int n1, int n2) {
     float x = 0.0;
     for (int i=0; i<n1; i++)
        for (int j=0; j<n2; j++)
           x += a[i][j];
     return x;
  }
  int main() {
     rarray<float,2> s(40, 40);
     float z = add6(s.const_ref().noconst_ptr_array(), 40, 40);
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt} 
\end{framed}

\pagebreak
\appendix

\section{Installation}

Rarray is a header-only library, so you could just copy the header \texttt{rarray} to the directory \texttt{/usr/include} or some other directory
that your C++ compiler searches for header files.  Alternatively, you could use the command
\begin{verbatim}
    make install PREFIX=[BASEDIR]
\end{verbatim}
This installs the header file in the \texttt{[BASEDIR]/include} directory,
and the documentation in\linebreak \texttt{[BASEDIR]/share/doc}.
If you have sudo permissions, you can also do
\begin{verbatim}
    sudo make install
\end{verbatim}
to install the header and documentation to /usr/include and /usr/share/doc,
respectively. Note that this will fail on recent MacOS versions,
in which case, try \texttt{sudo make install PREFIX=/usr/local}.

To modify rarray, do not edit the rarray header file, as this is a generated file. Instead, you
should edit the files in the \texttt{headersources} directory.  You
can use the included Makefile to assemble the rarray headers with
\begin{verbatim}
    make headers
\end{verbatim}

If you're editing the documentation (this file), you need pdflatex, and you should edit\linebreak \texttt{rarraydoc.tex} and then do
\begin{verbatim}
    make doc
\end{verbatim}

The Makefile can also be used to compile and run the unit tests and benchmarks. Simply do:
\begin{verbatim}
    ./configure
    make test
    make benchmarks
\end{verbatim}
The \texttt{configure} command should work under Linux if you have a recent
gnu, intel, ibm or clang compiler.  Note that to pick your compiler,
you may have the set the CXX environment variable point to the right
compiler command (e.g. \texttt{export CXX=clang++}) before running \texttt{configure}.

If the include directory is not in the compiler's search path, you
will need to pass an option to the compiler directing to that
directory (i.e. \texttt{-I[BASEDIR]/include}) or, for gcc and intel compilers,
set the CPATH environment variable.

\newpage

\section{History}

Dec 2013:

First implementation of the header-only library \texttt{rarray} for runtime multidimensional arrays.

\noindent
Jan 2014: Version 1.0

Code put on github

\noindent
Mar 2015: Version 1.1

Changed the text output format used to use newlines

\noindent
Feb 2017: Version 1.2

Added C++11 aliases rvector, rmatrix and rtensor. Eliminated the need
for rarraymacros.h and rarraydelmacros.h in the installed version of
rarray.

\noindent
Oct 2019: Version 2.0

Prompted by a deeply rooted memory leak, this version is a full
rewrite of rarray from the ground up, leaving most of the application
interface unchanged.  Rarray now \textbf{requires} C++11.
The optional but expensive capability to do index range checking has
partially been lost in the rewrite.  Rarray comes with its own unit testing
library now, 'rut'.

\noindent
Jan 2020: Version 2.1

Reference counting of rarray data is now done atomically, so copying
rarrays should now be thread-safe.  One-character names of
substructures, used in debugging rarray itself, were
removed. Streaming operators for rarrays moved to the \texttt{ra}
namespace.

\noindent
Feb 2020: Version 2.2

Several bug fixed with running and installing rarray on MacOS.  The
rarray unit test library 'rut' was dropped in favour of 'catch2',
which does everything that 'rut' was intended to do, but better. Since
'catch2' is header only, this makes running the tests on different
platforms much easier.

\noindent
Jan 2022: Version 2.3

Streaming I/O now part of the rarray header. rarrayio header is
obsolete, but kept for backwards compatibility. 

\noindent
Dec 2022: Version 2.4

Internal refactoring focussed on eliminating warnings, dead code,
version tracking in code, and exception safety.
Fixed bug for compound data types.
Support added for Intel OneAPI's icpx C++ compiler.

\noindent
Dec 2022: Version 2.5

Optional bounds checking is back.\\
\texttt{is\_clear} renamed to \texttt{empty}.\\
Can now get a subarray with square brackets.\\
Rarray objects no nolonger automatically convert into T*const*... pointers.\\
More extensive unit and coverage tests.


\end{document}
