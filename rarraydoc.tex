\documentclass[11pt,twoside]{article}
\usepackage{geometry,fancyhdr,hyperref,framed,charter,fullpage}
\setcounter{tocdepth}{1}
\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection\quad #1}}
\fancyhf{}
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries \hfill\rightmark\hfill}
\fancyhead[RE]{\hfill\bfseries\rightmark \hfill}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{15pt}
\fancypagestyle{plain}{\fancyhead{}\renewcommand{\headrulewidth}{0pt}}
\let\oldtt=\tt
%\renewcommand{\texttt}[1]{\color{blue}\tt #1\color{black}}
\newcommand{\cxx}{C{++}}

%\renewcommand{\texttt}[1]{#1}
\begin{document}

\setlength{\parskip}{1mm}

\title{\texttt{rarray}: Reference-Counted Multidimensional Arrays for \cxx}

\author{Ramses van Zon%\\
%\it\small SciNet High Performance Computing Consortium, University
%of Toronto, Toronto, Ontario, Canada
\vspace{-8pt}} 

\date{November, 2023 (version 2.6.1)\vspace{-7mm}}

\maketitle

\section{For the impatient: the what, why and how of rarray}

\noindent\textbf{What:}\\
Reference-counted and non-owning multidimensional arrays with runtime dimensions. 

\noindent\textbf{What not:}\\
No strides, no linear algebra, overloaded operators etc.

\noindent\textbf{Why:}\\
Usually faster than alternatives.\\
Uses the same accessors as automatic arrays.\\
Requires only the \cxx-11 standard.\\
Data is contiguous to allow interfacing with
libraries like BLAS, LAPACK, FFTW, etc.

\noindent\textbf{How:}\\
The header file \texttt{rarray} provides the type \texttt{rarray<T,R>}, where \texttt{T} is any type and {\tt R} is the rank. Element access uses repeated square brackets. Copying rarrays or passing them to functions mean shallow copies, unless explicitly asking for a deep copy. Streaming I/O is also supported.\vspace{2mm}

\centerline{\begin{tabular}{|l|l|}
\hline
\rule{0pt}{14pt}Define a \texttt{n$\times$m$\times$k} array of \texttt{float}s:&
\texttt{rarray<float,3> b(n,m,k);}
\\
\rule{0pt}{14pt}Define a \texttt{n$\times$m$\times$k} array of \texttt{float}s with&
\\
data pre-allocated at a pointer \texttt{ptr}:&
\texttt{rarray<float,3> c(ptr,n,m,k);}
\\
\rule{0pt}{14pt}Element i,j,k of the array \texttt{b}:&
\texttt{b[i][j][k]}
\\
\rule{0pt}{14pt}Pointer to the contiguous data in \texttt{b}:&
\texttt{b.data()}
\\
\rule{0pt}{14pt}Total number of elements in \texttt{b}:&
\texttt{b.size()}
\\
\rule{0pt}{14pt}Extent in the \texttt{i}th dimension in \texttt{b:}&
\texttt{b.extent(i)}
\\
\rule{0pt}{14pt}Array of all extents of \texttt{b}&
\texttt{b.shape()}
\\
\rule{0pt}{14pt}Define an array with same shape as \texttt{b}&
\texttt{rarray<float,3> b2(b.shape());}
\\
\rule{0pt}{14pt}Shallow, reference-counted copy of the array:&
\texttt{rarray<float,3> d=b;}
\\
\rule{0pt}{14pt}Deep copy of the array:&
\texttt{rarray<float,3> e=b.copy();}
\\
\rule{0pt}{14pt}A rarray using an existing automatic array:&
\texttt{float f[10][20][8]=\{\{\{\dots\}\}\};}\\
&
\texttt{rarray<float,3> g(f);}
\\
\rule{0pt}{14pt}Output a rarray to console:&
\texttt{std::cout << h << std::endl;}
\\
\rule{0pt}{14pt}Read a rarray from console:&
\texttt{std::cin >> h;}
\\\hline
\end{tabular}}


\newpage
\
\tableofcontents
\newpage
\section{Introduction}

While C and thus \cxx\ has some support for multidimensional arrays
whose sizes are known at compile time, the support for arrays with
sizes that are known only at runtime, is limited. For one-dimensional
arrays,  \cxx\ has a reasonable allocation and deallocation constructs in the operators
\texttt{new} and \texttt{delete} in the standard.  A standard way to allocate a
one-dimensional array is as follows:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
int n = 1000;
float* a = new float[n];
a[40] = 2.4; // as an example on how to use this, access element at offset 40
delete[] a;
\end{verbatim}%
\vspace{-12pt}\end{framed}\vspace{-5pt}\noindent%
It is important to note that this code also works if \texttt{n} was
not known yet at compile time, e.g., if it was passed instead as a function
argument or read in as input.

This style of allocation with a
``raw'' pointer is discouraged in \cxx\ in favor of using ``smart''
pointers, which is possible since the C++17 standard:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
int n = 1000;
std::unique_ptr<float[]> a(new float[n]); 
a[40] = 2.4; // as an example on how to use this, access element at offset 40
// a gets deallocated automatically, or one can explicitly call a.reset(nullptr)
\end{verbatim}%
\vspace{-12pt}\end{framed}\vspace{-5pt}\noindent%
Automatic deallocation happens when the variable \texttt{a} goes out of scope.
A unique pointer cannot be copied.  Instead of
\texttt{unique\_ptr} one can use \texttt{shared\_ptr}, which can be
copied and keeps a reference counter to know when to deallocate the
memory.  Then, deallocation happens when the life time of all copies
of the \texttt{shared\_ptr} has ended.

In the above code snippets, the \texttt{new} construct and the
\texttt{std::unique\_ptr/std::shared\_ptr} assign the address of the
array to a pointer. These pointers do not remember their size, so they
are not really an 'array'.  The standard \cxx\ library does provide a
dynamically allocated one-dimensional array that remembers its size, in the form of the \texttt{std::vector}, e.g.
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
int n = 1000;
std::vector a(n);
a[40] = 2.4; // as an example on how to use this, access element at offset 40
// a gets automatically deallocated, or one can explicitly call a.clear()
\end{verbatim}%
\vspace{-12pt}\end{framed}\vspace{-5pt}%

Multi-dimensional runtime-allocated arrays are currently not supported yet by
\cxx, but there is a proposal for a non-owning multidimensional array in
the C++23 standard, and C++26 may have an owning multidimenstional
array.

To handle these kinds of arrays in \cxx, the (early) textbook solution for multidimensional arrays that are
dynamically allocated during runtime, would be as follows (here for a
three-dimensional array of \texttt{dim0}$\times$\texttt{dim1}$\times$\texttt{dim2})
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  float*** A;
  A = new float**[dim0];
  for (int i=0;i<dim0;i++) {
    A[i] = new float*[dim1];
    for (int j=0;j<dim1;j++) 
      A[i][j] = new float[dim2];
  }
  A[1][2][3] = 105; // as an example
\end{verbatim}%
\vspace{-12pt}\end{framed}\vspace{-5pt}\noindent%
Apart from the fact this will soon be obsolute, drawbacks of this solution are:
\begin{itemize}
  \item the elements are not stored contiguously in memory, making
    this multi-dimensional array unusable
    for many numerical libraries,
  \item one has to keep track of array dimensions, and pass them along
    to functions,
  \item the intermediate pointers are non-const, so the
    internal pointer structure can be changed
    whereas, conceptually, \texttt{a} ought to be of type \texttt{float*const*const*}.
\end{itemize}
At first, there seems to be no shortage of libraries to fill this
lack of \cxx\ support for dynamic multi-dimensional arrays, such as
\begin{itemize}\itemsep 0pt \parskip 0pt
\item Blitz++;
\item The Boost Multidimensional Array Library (\texttt{boost::multiarray}); 
\item Eigen;
\item Armadillo
\item Nested \texttt{vector}s from the Standard Template Library; and
\item Kokkos's reference implementation of the C++23 mdspan template.
\end{itemize}
These typically do have some runtime overhead compared to the above
textbook solution, or do not allow arbitrary ranks. In contrast, the purpose of the rarray
library is to be a minimal interface for runtime multidimensional
arrays of
arbitrary rank with
\emph{minimal to no performance overhead} compared to the textbook
solution.  From the above list of library solutions, only the  implementation in
Kokkos of the non-owning mdspan has virtually no overhead.

Rarray aims to be simpler; all it takes to create a three-dimensional 
\noindent{\bf Example:\vspace{-7pt}}
\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  #include <rarray>
  ...
     rtensor<float> A(dim0,dim1,dim2);
     A[1][2][3] = 105; // as an example
  ...
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}%
\end{framed}

\noindent{\bf Design Points of rarray}

\begin{enumerate}\itemsep1pt\parskip3pt
 
\item To have dynamically allocated multidimensional arrays that
combine the ease and convenience of automatic \cxx\ arrays while being compatible
with the
typical textbook-style dynamically allocated pointer-to-pointer
structure. 

The compatibility requirement with pointer-to-pointer structures
is achieved by allocating a pointer-to-pointer structure. This
structure accounts for most of the memory overhead from using \texttt{rarray}.

\item To be as fast as pointer-to-pointer structures.

\item To do shallow copy by default, deep copy possible.
  
\item To have rarrays know their sizes, so that they can be passed to
functions as a single argument. 

\item To enable interfacing with libraries such as BLAS, LAPACK and FFTW: this
  is achieved by guarranteeing contiguous elements in the
  multi-dimensional array, and a way to get this data out.

  The guarrantee of contiguity means strided arrays are not supported.

\item To allow sharing between components of an application while
  avoiding dangling references. This is possible by utilizing reference counting.

\item To allow rarrays to hold non-owning views that use an existing buffer,
  without having to use a separate type.

\item To avoid some of the cluttered sematics around \texttt{const}
  correctness when converting to pointer-to-pointer structures when
  interfacing with legacy code.

\end{enumerate}

\noindent{\bf Features of rarray:\vspace{-3pt}}
\begin{itemize}\itemsep0pt\parskip2pt
\item Can use any data type {\tt T} and any rank {\tt R}.
\item Elements are accessible using repeated square brackets, like C/C++ arrays.
\item Views on pre-allocated contiguous arrays.
\item Does shallow, (atomic) reference counted, copies by default, but also has a deep {\tt copy}
  method.
\item Use of \cxx11 move semantics for efficiency.
\item Can be emptied with the {\tt clear} method.
\item Can be filled with a uniform value with the {\tt fill} method.
\item Can be reshaped.
\item Automatic C-style arrays can be converted to rarrays.
\item A method {\tt empty} to check if the rarray is uninitialized.
\item A method to get the number of elements in each
  dimension (\texttt{extent}), or in all dimensions (\texttt{shape}).
\item A method to obtain the total number of elements in the
  array (\texttt{size}).
\item A method to make the data type of the array const
  (\texttt{const\_ref}).  Used in automatic conversion from
  \texttt{rarray<T,R>} to \texttt{rarray<const T,R>}.
\item Conversion methods using the member
  function \texttt{data()} for conversions to a \texttt{T*} or
  \texttt{const T*}, using the method \texttt{ptr\_array()} for
  conversions to \texttt{T*const*} or \texttt{const T*const*}, and
  using the method \texttt{noconst\_ptr\_array()} for the conversion to a
  \texttt{T**}.
\item Streaming input and output.
\item Checks index bounds if the preprocessor constant {\tt RA\_BOUNDSCHECK} is defined. 
\end{itemize}

\section{Using rarrays}

\subsection{Defining a multidimensional rarray}
\label{definerarray}

To use \texttt{rarray}, first include the header file:
\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  #include <rarray>
\end{verbatim}%
\vspace{-14pt}
\end{framed}
\noindent
This defines the (template) classes \texttt{rarray{\tt<}T,R{\tt>}}, where
\texttt T is the element type, and \texttt R is the
rank (a positive integer).  Instances can now be
declared as follows:
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  rarray<float,3> s(256,256,256);
  // do whatever you need with s
  s[1][2][3] = 105;
\end{verbatim}%
\vspace{-14pt}
\end{framed}
\noindent
In this case, calling \texttt{s.clear()} would
release the memory of this array. Otherwise, the memory will be
released when the rarray goes out of scope. That is unless a copy of
\texttt{s} was made before either of these happened.

It is als possible to use an external, pre-allocated buffer, as follows:
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  std::unique_ptr<float[]> pre_alloc_data(new float[256*256*256]); 
  rarray<float,3> s(pre_alloc_data,256,256,256);
  s[1][2][3] = 105;
  // do whatever you need with s
\end{verbatim}%
\vspace{-14pt}
\end{framed}
Note that \texttt{s} will have dangling references (often leading to
``Segmentation faults'') if \texttt{pre\_alloc\_data} is deallocated while \texttt{s} is
not gone out of scope or \texttt{clear}-ed.

The construction specifying a number of extents as arguments works for arrays with rank up to and including 11. For arrays with larger rank, you have to pass an pointer to the array of extents.

\subsection{Shorthand rarray types: rvector, rmatrix, rtensor}

For convenience, rarray defines shortcut types for
one-dimensional, two dimensional and three dimensional arrays, called
rvector, rmatrix and rtensor, respectively. The following equivalences hold:

\begin{framed}\vspace{-18pt}%
\begin{verbatim}
rvector<T> = rarray<T,1>
rmatrix<T> = rarray<T,2>
rtensor<T> = rarray<T,3>
\end{verbatim}
\vspace{-18pt}\end{framed}\noindent
for any type \texttt{T}.

\subsection{Accessing elements of an rarray}

The elements of rarray objects are accessed using the repeated square
bracket notation as for automatic \cxx\ arrays. Thus, if \texttt{s} is a \texttt{rarray} of rank \texttt R, the elements are accessed using \texttt{R} times an index of the form \texttt{[n$_i$]}, i.e. \texttt{s[n$_0$][n$_1$]\dots[n$_{\texttt{R}-1}$]}
For example:\vspace{-9pt}
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  for (int i=0;i<s.extent(0);i++)
    for (int j=0;j<s.extent(1);j++)
      for (int k=0;k<s.extent(2);k++)
        s[i][j][k] = i+j+k;
\end{verbatim}%
\vspace{-12pt}
\end{framed}%\vspace{-8pt}\noindent

In addition to the explicit assignment of each element, there is an
alternative way to assign values to the elements of an rarray using a
comma separate form, as follows
\vspace{-9pt}
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  rarray<double,2> matrix(3,3);
  matrix = 1,2,3,
           4,5,6,
           7,8,9;
\end{verbatim}%
\vspace{-12pt}
\end{framed}\vspace{-8pt}\noindent
This is usefully, for instance, for small matrices (e.g.\ in tests). Entering
large rarrays in this way would be rather impractical.

\subsection{Copying and function arguments}

In C++, when we copy a variable of a built-in type to a new variable,
the new copy is completely independent of the old variable. Likewise,
the default way of passing arguments to a function involves a complete
copy for built-in types.  For C-style arrays, however, only the
pointer to the first element gets copied, not the whole array. The
latter is called a shallow copy. Rarrays use shallow copies much like
pointers, but use atomic reference counting to know when memory can
be released (similar to the \texttt{std::shared\_ptr<T>} of C++11 and
\texttt{std::shared\_ptr<T[]>} of C++14). 

What does this essentially mean? Well:
\begin{enumerate}
\item You can pass rarrays by value to function, which is as if you
  were passing a pointer.\linebreak (Passing by reference also works.)
\item When you assign one rarray to another, the other simply points to the old one.
\item If you wish to do a deep copy, i.e., create a new array independent of the old array, you need to use the \texttt{copy} method.
\end{enumerate}

\subsection{Returning a rarray from a function\label{returnvalues}}

Because rarray implements move semantics, returning an rarray from a
function does not pose any problems.

Consider the function \texttt{zeros} used in \texttt{main()}:
\vspace{-9pt}
\begin{framed}\vspace{-12pt}%
%TEST THIS
\begin{verbatim}
#include <rarray>
rarray<double,2> zeros(int n, int m) {
   rarray<double,2> r(n,m);
   r.fill(0.0);
   return r;
}
int main() {
   rarray<double,2> s = zeros(100,100);
   return s[99][99];
}
\end{verbatim}%
%END TEST THIS
\vspace{-12pt}
\end{framed}\vspace{-8pt}
In line 3, a rarray \texttt{r} is created, and filled, on line 4, with
zeros. On line 5, \texttt{r} gets moved out of
the function and into \texttt{s}, using C++11's move
semantics. Move semantics cause \texttt{r} to be left in an empty state
that will not deallocate the memory associated with the array \texttt{s}.

\subsection{Reshaping the rarray}

To use the data in an rarray but access it in a different `shape', one
has several options.
\begin{enumerate}
  \item One can create a new rarray which uses the data from the first rarray. E.g.
\vspace{-9pt}
\begin{framed}\vspace{-3pt}%
\begin{verbatim}
void dump(const rarray<double,3>& r) {
   rarray<double,1> rflat(r.data(), r.size());
   for (int i=0;i<r.size();i++)
       std::cout << rflat[i] << ' ';
   std::cout << std::endl;
}
\end{verbatim}%
\vspace{-12pt}
\end{framed}\vspace{-8pt}
\item Alternatively, one can reshape the existing rarray with the desired
  dimensions. E.g.
\vspace{-2pt}
\begin{framed}\vspace{-4pt}%
\begin{verbatim}
void dump(rarray<double,3> r) {
   r.reshape(1, 1, r.size());
   for (int i=0;i<r.size();i++)
       std::cout << r[0][0][i] << ' ';
  std::cout << std::endl;
}
\end{verbatim}%
\vspace{-12pt}
\end{framed}\vspace{-8pt}
\end{enumerate}
The latter only works if the new and old shape have the same ranks and
the number of elements stays the same. It is possible to reshape an
rarray to have less elements, but only by explicitly passing a last
parameter \texttt{ra::RESIZE::ALLOWED}, e.g.
\begin{framed}\vspace{-4pt}%
\begin{verbatim}
void dump(rarray<double,3> r) {
   r.reshape(1, 1, r.size()/2, ra::RESIZE::ALLOWED);
   for (int i=0;i<r.size();i++)
       std::cout << r[0][0][i] << ' ';
  std::cout << std::endl;
}
\end{verbatim}%
\vspace{-12pt}
\end{framed}\vspace{-8pt}
\noindent It should be stressed that the last examples have no side effects for
the shape of the original rarray that was passed to the function.
The rarray was passed by value, which means the function holds a shallow
copy, but the \texttt{reshape} method creates an new indepdent shape
while using the same buffer as the original array.
the original array retains its shape. It the array was passed by
reference, the original array would be changed when applying \texttt{reshape}.

As a design decision, the reshape method should not allocated any
memory. Thus, it is never possible to do a reshape that leads to more
elements.

\subsection{Optional bounds checking}

If the preprocessor constant \texttt{{\tt RA\_BOUNDSCHECK}} is defined, an
\texttt{out\_of\_bounds} exception is thrown~if
\begin{itemize}\itemsep0pt\parskip3pt
\item an index is too small or too large;
\item the size of dimension is requested that does not exist (in a call to \texttt{extent(int i)});
\item a constructor is called with a zero pointer for the buffer or
  for the shape array;
\end{itemize}
\texttt{{\tt RA\_BOUNDSCHECK}} can be defined by
adding the {\tt -DRA\_BOUNDSCHECK} argument to the compilation command, or
by \texttt{{\tt\#define RA\_BOUNDSCHECK}} before
the \texttt{{\tt\#include <rarray>}} in the source.

%\pagebreak

\section{Comparison with standard alternatives}

Compared to the old textbook method of declaring an array (see above), or the rarray method:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
#include <rarray>
int main() {
  int n = 256;
  rarray<float,3> arr(n,n,n); 
  arr[1][2][3] = 105; // for example
}
\end{verbatim}
\vspace{-14pt}\end{framed}
\noindent
the more-or-less equivalent automatic array version 
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
int main() {
  int n = 256;
  float arr[n][n][n]; 
  arr[1][2][3] = 105; // for example
}
\end{verbatim}
\vspace{-14pt}\end{framed}
\noindent
is a little simpler, but automatic arrays are allocated on the stack,
which is typically of limited size. Another big drawback is that this array cannot be passed to functions that do
not hard-code exact matching dimensions except for the last
one.

Using rarray also has benefits over another \cxx\ 
solution, i.e. using the \texttt{std::vector} class from the Standard Template Library:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  #include <vector>
  int main() {
     using std::vector;
     int n = 256;                // size per dimension
     vector<vector<vector<float>>> v(n);// allocate for top dimension
     for (int i=0;i<n;i++) {
        v[i].resize(n);         // allocate vectors for middle dimension
        for (int j=0;j<n;j++) 
           v[i][j].resize(n);   // allocate elements in last dimension
     }
     v[1][2][3] = 105;           // assign to element (for example)
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}\end{framed}\vspace{-8pt}
\noindent
which is complicated, is non-contiguous in memory, and likely
slower.

C++23 will have a non-owning library, mdspan, which should work
roughly as follows:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  #include <memory>
  #include <mdspan>
  int main() {
     int n = 256;                  // size per dimension
     std::unique_ptr<float[]> p (new float[n*n*n]); // or vector or a shared_ptr
     using exts = std::extents<size_t,std::dynamic_extent,
                  std::dynamic_extent,std::dynamic_extent>;
     std::mdspan<float,exts> (vector.data(), exts(n,n,n));
     v[1,2,3] = 105;               // assign to element (for example)
  }
\end{verbatim}%
\vspace{-14pt}\end{framed}\vspace{-8pt}
Which is more involved that the rarray solution and does not offer
reference counting.  


\pagebreak[4]
\section{Class definition}

\subsection{Interface}
Effectively, the interface part of a rarray object is defined as follows:%
\vspace{-8pt}%
\begin{framed}\vspace{-14pt}%
\begin{verbatim}
namespace ra {
template<typename T, rank_type R>
class rarray {
public:    
 rarray();                                 // create uninitialized array
 rarray(size_type extent0, ...);           // constructor for R<=11
 rarray(const size_type* extents);         // alternative: extents in array
 rarray(T* data, size_type extent0, ...);  // construct with existing data
 rarray(T* data, const size_type* extents);// alternative: extents in array
 rarray(const rarray<T,R> &a);             // shallow copy constructor   
 ~rarray();                                // destructor 
 void reshape(size_type extent0, ...);     // change shape (not data) for R<=11
 void reshape(const size_type* size_type); // change shape (not data)
 void clear();                             // release memory
 void fill(const T& value);                // fill with uniform value
 bool empty() const;                       // check if uninitialized
 rarray<T,R> copy() const;                 // deep copy
 const size_type*  shape() const;          // all extents as C-style array
 size_type extent(int i) const;            // extent in dimension i
 size_type size() const;                   // total number of elements
 rank_type rank() const;                   // rank, i.e, the value of R
 T* data() const;                          // start of internal buffer
 T*const*... ptr_array() const;            // convert to a T*const*... 
 T**... noconst_ptr_array() const;         // converts to a T**... 
 rarray<const T,R>&  const_ref() const;    // convert to const elements
 rarray<T,R>& operator=(const rarray<T,R> &a);// shallow assignment
 operator[](size_type i) const;  // enables const element access
 operator[](size_type i);        // enables element access for assignment
 rarray<T,R-1> at(size_t i);      // retrieve the ith 'row' with bounds checking
};
}
\end{verbatim}\vspace{-14pt}
\end{framed}

\subsection{Methods}

%\subsubsection{Get size in each dimension: \tt extent}
\noindent\textbf{Definition:} \texttt{size\_type extent(rank\_type i) const;}

This method returns the size of dimension \texttt{i}.

%\subsubsection{Get size in each dimension: \tt extent}
\noindent\textbf{Definition:} \texttt{const size\_type* shape() const;}

This method returns the size of all dimensions as a c array. 

%\subsubsection{Get total size: \tt size}
\noindent\textbf{Definition:} \texttt{size\_type size() const;}

This method returns the total number of elements.

\noindent\textbf{Definition:} \texttt{rank\_type rank() const;}

This method returns the number of dimensions.

%\subsubsection{Get pointer equivalent: \tt data}

\noindent\textbf{Definition:} \texttt{T* data() const;}

This method returns a pointer to the first element of the array.

%\subsubsection{Get pointer equivalent: \tt ptr\_array}

\noindent\textbf{Definition:} \texttt{T*const*... ptr\_array() const;}

This method returns a pointer to a \texttt{T*const*...}.  Note that
rarrays have an automatic conversion to this type.

%\subsubsection{Get const-casted pointer equivalent: \tt noconst_ptr\_array}

\noindent\textbf{Definition:} \texttt{T**... noconst\_ptr\_array() const;}

This method returns a pointer to a \texttt{T**...}. (This conversion breaks const-correctness.)

%\subsubsection{Get const-content equivalent: \tt const\_ref}

\noindent\textbf{Definition:} \texttt{rarray{\tt<}const T,R{\tt>}\& const\_ref() const;}

This method creates reference to this with const elements.

\noindent\textbf{Definition:} \texttt{void reshape(size\_type extent0, ...);}

This method can be used to change the shape of the rarray. The data in
the underlying buffer will not change. Note that the number of
dimensions (i.e., the rank) must remain the same and the total new size must be less or equal to the old size.  This works only for arrays with rank up to and including 11. 

\noindent\textbf{Definition:} \texttt{void reshape(const int* extents);}

Same as the previous \texttt{reshape} method, but takes an array of new dimensions as an argument.  This is the only way to reshape an array of rank twelve or higher.

\noindent\textbf{Definition:} \texttt{void clear();}

This method release memory the memory associated with the rarray. If the rarray was created by providing a pre-existing buffer for the data, the memory of this buffer does not released.

\noindent\textbf{Definition:} \texttt{void fill(const T\& value);}

This method fills the array with a uniform value \texttt{value}.

\noindent\textbf{Definition:} \texttt{bool empty();}

Checks if the rarray is in an uninitialized state.

\noindent\textbf{Definition:} \texttt{rarray{\tt<}T,R{\tt>} copy() const;}

This method creates deep copy of the rarray, i.e., an independent rarray with the same dimensions are the original rarray and with its content a copy of the original rarray's content.

\section{I/O}

\subsection{Streaming input and output}

Although it is usually preferrable to store large arrays in binary, rarray does provide streaming operators \texttt{<<} and \texttt{>>} to read and write to standard C++ iostreams in text format.

The output produced by the output streaming operator is like that of
automatic arrays initializers: Each dimension is started and ended by
\texttt{\{} and \texttt{\}} and components are comma separated.
Except for the inner dimension, newlines are included in the output,
but no spaces, and no trailing newline.
E.g.:\vspace{-9pt}
\begin{framed}\vspace{-18pt}%
%TEST THIS
\begin{verbatim}
  #include <iostream>
  #include <rarray>
  int main() {
    int buf[6] = {1,2,3,4,5,6};
    rarray<int,2> arr(buf,3,2);
    std::cout << arr;
  }
\end{verbatim}%
%END TEST THIS
\vspace{-12pt}
\end{framed}\vspace{-8pt}\noindent
will print the following:
\begin{verbatim}
{
{1,2},
{3,4},
{5,6}
}
\end{verbatim}
Apart from inserting curly braces, commas, and newlines, the streaming
operators use the streaming operators of the element types. 

The streaming operators are designed such that the format that is
written out by the \texttt{<<} operator, should be readable by the
\texttt{>>} operator.  
Without further formatting rules, reading would not be unambiguous for
some types, e.g. for
\texttt{std::string}, that can contain the syntactic elements
`\texttt{\{}', `\texttt{\}}', `\texttt{,}', or `\texttt{\#}'.  If these elements are found in the output of an element, the element is prepended with a string that encodes the string length of the output. This prepending string starts with a '\texttt\#' character, then the length of the string output for the element  (excluding the prepended part), followed by a `\texttt:' character.

An exception to the '\texttt\#' formatting rule exists for types that
stream out such that the first output character is '\texttt(' and the
last is '\texttt)', with no other '\texttt)' characters
intervening. Such output does not require the '\texttt\#'
formatting. Complex numbers are a primary example of a type with such
output and input.

Note that while the input stream operators expect the same format as
the output produces by the output streams, they but will
not care if newlines are not there. However, there should not be any extraneous
whitespace in the input.

\section{Utilities: xrange and linspace}

The rarray library contains a few more utilities.

\subsection{xrange}

The xrange function returns an iterable generator, which can produce
numbers from a starting point, with some step size, up to but not
including an end point.  In the simplest case, this can be used as a
counter, e.g.:
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  #include <iostream>
  #include <rarray>
  int main() {
    for (int i: xrange(1000))
      std::cout << i << " ";
    std::cout << std::endl;
  }
\end{verbatim}\vspace{-14pt}
\end{framed}
will print the numbers 0 to 999, which are generated in succession,
i.e., no integer array of size 1000 containing these numbers is ever
created. The return type of the xrange function is an
\texttt{ra::Xrange<T>} object, with \texttt{T} equal to \texttt{int}
in the above example.  This is an iterable object that can be used in
a range-based for.  It could also be used as the source of a copy, and
thus to initialize an rarray, e.g. you could get an array with values
\texttt{0,2,4,...,998}, as follows
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  #include <rarray>
  #include <algorithm>
  int main() {
    ra::Xrange<int> in = xrange(0,1000,2);
    rvector<int> r(500);
    std::copy(in.begin(), in.end(), r.begin());
    ...
  }
\end{verbatim}\vspace{-14pt}
\end{framed}
(replacing the type \texttt{ra::Xrange<int>} with c++11's
\texttt{auto} seems like a good idea here).

The general form of the range function is
\begin{verbatim}
ra::Xrange<T> xrange(T endvalue)
ra::Xrange<T> xrange(T beginvalue, T endvalue, T stepsize=1)
\end{verbatim}
In the first form, the begin value is 0 and the stepsize is 1. These
are template functions, where T can be any type that can be converted
to a double, although the most useful cases are those where T is an
integer.  In all cases, the first generated value is exactly
\texttt{beginvalue}, each subsequent value is one stepsize larger, and
the endvalue is the first value that is not generated (to be precise,
the number of numbers generated is
\texttt{ceil((beginvalue-endvalue)/stepsize)}, using floating point
division).

The case where \texttt{endvalue} is less than \texttt{beginvalue}, or
for which \texttt{stepsize} is negative, are, in version 2.1 - 2.6 of rarray, undefined.

\subsection{linspace}

The \texttt{linspace} function returns a rvector with a specified
number of points between two given values, inclusively.  The general
form of the function is
\begin{verbatim}
rvector<T> linspace(T x1, T x2, int n, bool end_incl=true);
\end{verbatim}
Here, \texttt{x1} is the first value, \texttt{x2} the
last value, and \texttt{n} is the number of values.  If
the latter is not given or is set to zero, the number of values is
such that the stepsize is as close to one as possible. If
\texttt{end\_incl} is set to false, the generated values are such as if
the number of points is \texttt{n+1} but the last value is omitted.

For example, to create an \texttt{rvector} with 101 equally spaced
values between $-1.0$ and $1.0$, one would do
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  #include <rarray>
  int main() {
    rvector<double> r = linspace(-1.0, 1.0, 101);
    ...
  }
\end{verbatim}\vspace{-14pt}
\end{framed}
The first argument of linspace is allowed to be greater than the last,
in which case, decreasing values are generated.  The two arguments are
allowed to be equal as well, which generates a vector with all equal values. In that case, \texttt{end\_incl} can not
be set to false. The case where the number of points is 1 and
\texttt{end\_incl=false} is ill defined.

Note that for integer types, using linspace without specifying their
number (i.e. \texttt{linspace(n1,n2)}) gives the same values as are
generated by the xrange function without a stepsize and with the
endvalue one higher (i.e., \texttt{xrange(n1,n2+1)}).


\section{Performance}

\subsection{General performance consideration}

\noindent
\texttt{rarray} is written specifically with performance in
mind. However, the way it manages to mimic the natural c and c++ way
of using multi-dimensional arrays, i.e. with (repeated) square
brackets, would come at a high cost of function calls and temporary
objects. The rarray library tries to inline most function calls to avoid this
cost, but it needs the c++ compiler's optimization capabilities to
help out. Even the lowest optimization levels, such as obtained with
the \texttt{-O1} flag, will enable this for many compilers, though some will need hight levels of optimization.

Rarray is meant to be used with higher levels of optimization. When
compiled with higher optimization levels, such as \texttt{-O3
  -fstrict-aliasing} for \texttt{g++}, inlining should make the rarray
objects at least as fast as the textbook solution for multidimensional
arrays mentioned in the introduction.

\subsection{Debugging}

When debugging a code with a symbolic debugger (e.g. gdb), in addition
to compiling with an option to include ``symbols'' (i.e., names of
functions and other information regarding the code) into
the executatble (e.g. \texttt{-g}), one usually switches off the
compiler's optimization capabilities (\texttt{-O0}), because it can
change the order of instructions in the code, which makes debugging
very difficult. As explained above, when working with rarray, turning
of the compiler's optimization options can cause the program to
become quite a bit slower, which can also hamper debugging.  If the
bug is unlikely to occur in rarray, it may be worth trying build with
a mild optimization level such as \texttt{-O1} for debugging.

If, on the other hand, the bug is in rarray, one likely needs to
switch off optimization to see what is going on.  In addition to the
\texttt{-O0} flag, this also requires switching off forced inlining,
using the \texttt{-DRA\_INLINE=inline} flag.

\subsection{Profiling}

Sampling profiling tools (such as \texttt{gprof}) work by periodically
recording the state and call stack of the program as it runs.  They
can be very useful for performance analysis. When using these tools
with rarray, it is advisable to compile with a minimum level of
optimization \texttt{-O1}. Otherwise, a lot of the internal function
calls of rarray that could simply be optimized away, and would pollute
the sampling. 

\subsection{Memory overhead using the rarray class}

The memory overhead here comes from having to store the dimensions and a pointer-to-pointer structure.  The latter account for most of the memory overhead.   A rarray object of 100$\times$100$\times$100$\times$100  doubles on a 64-bit machine will have a memory overhead of a bit over 1\%. In general, the memory overhead as a percentage is roughly 100\% divided by the last dimension. Therefore, avoid rarrays with a small last dimension such as 100$\times$100$\times$100$\times$2.

\subsection{Compilation overhead using the rarray class}

There is an overhead in the compilation stage, but this is very compiler dependent.

\section{Working with libraries}
\label{libraries}

Performance was one reason for writing the rarray library.  Being able
to pass such arrays to numerical libraries was another.

Many numerical libraries, such as BLAS, LAPACK and FFTW, are C or
Fortran based and their API requires that
\begin{enumerate}
\item the array elements are stored contiguously in memory,
\item one passes the pointer to the first element, and
\item one passes the dimensions of the array explicitly.
\end{enumerate}
Rarray helps in satisfying these requirement as follows:
\begin{enumerate}
\item Elements of a rarray are always stored contiguously in memory.
\item The pointer to the first elements of the array can be found with
  the member function \texttt{data()}.
\item The dimensions of the arrays can be found from
    the \texttt{extent} or \texttt{shape} member functions of rarray (or, for
    one-dimensional arrays, also with the \texttt{size} member function).
\end{enumerate}

Here is an example to call the matrix-matrix multiplication routine
from blas, using the cblas interface:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TET THIS
\begin{verbatim}
  #include <iostream>
  #include <rarray>
  #include <cblas.h>
  void matrix_product(const rmatrix<double> A,
                      const rmatrix<double> B,
                      rmatrix<double> C)
  {
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  C.extent(0), C.extent(1), A.extent(1), 1.0,
                  A.data(), A.extent(1),
                  B.data(), B.extent(1),
                  1.0,
                  C.data(), C.extent(1));
  }
  int main() {
     int m=2, k=3, n=4;
     rmatrix<double> A(m,k), B(k,n), C(m,n);
     A = 1,-2,3,
         2,-1,0;
     B = -1,3,-2,1,
         -2,1,-3,2,
         -3,2,-1,3;
     matrix_product(A,B,C);
     std::cout << "A=" << A << '\n'
               << "B=" << B << '\n' 
               << "C=A*B=" << C << '\n';
  }
\end{verbatim}%
%END TET THIS
\vspace{-14pt}\end{framed}\vspace{-8pt}
\noindent
See the (C)BLAS documentation for the precise meaning and operation of
cblas functions.

When working with complex data, an extra conversion may be
required. For instance, working with the library called FFTW3, the
following is a way to compute the fourier transform of a complex
rarray:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TET THIS
\begin{verbatim}
  #include <iostream>
  #include <complex>
  #include <rarray>
  #include <fftw3.h>
  int main() {
     int n = 4;
     rvector<std::complex<double>> a(n), b(n);
     a = 1.3+5.0i, 1.0, 5.0i, 2.0-5.0i;
     fftw_plan plan = fftw_plan_dft_1d(a.size(),
                        (fftw_complex*)a.data(), (fftw_complex*)b.data(), 
                        FFTW_FORWARD, FFTW_ESTIMATE);
     fftw_execute(plan);
     fftw_destroy_plan(plan);
     std::cout << "a=" << a << '\n' << "FT(a)=" << b << '\n';
  }
\end{verbatim}%
%END TET THIS
\vspace{-14pt}\end{framed}\vspace{-8pt}
\noindent
Note that this example uses the concise c++14 notation for complex
variables (compile with \texttt{-std=c++14} or equivalent). Again, for the precise meaning of the fftw function call, see the documentation of
that library.

Finally, it is worth noting that many numerical libraries care about
the ``alignment'' of the data.  Rarray currently does not have any way of
facilitating alignment, but a user can allocate aligned
data and pass it as a pre-existing buffer to the rarray constructor
(see \ref{definerarray}).

\section{Conversions}

\subsection{Converting automatic C-style arrays to rarrays}

It is possible to convert C-style automatic arrays to rarrays if they
have a rank of at most 11.
The main convenience of this is that one can write functions that take rarray argument(s) and pass automatic arrays to them. Another use is in initializing a rarray. For example:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
#include <iostream>
#include <rarray>
void print2d(const rarray<float,2> &s) {
    for (int i=0; i<s.extent(0); i++) {
        for (int j=0; j<s.extent(1); j++)
            std::cout << s[i][j] << ' ';
        std::cout << std::endl;
    }
}
int main() {
    float stackarray[4][4] = { { 1.0, 1.2, 1.4, 1.6},
                               { 2.0, 2.2, 2.4, 2.6},
                               { 3.0, 3.2, 3.4, 3.6},
                               { 4.0, 4.2, 4.4, 4.6} };
    // automatic conversion
    print2d(stackarray);
    // view using the same data
    auto a = rarray<float,2>(stackarray);
    print2d(a);
    // independent copy of the same data
    auto b = rarray<float,2>(stackarray).copy();
    print2d(b);
}
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}\end{framed}\vspace{-8pt}


\subsection{Conversions for function arguments}

A function might take a \texttt{rarray{\tt<}const T,R{\tt>}} parameter
if elements are not changed by it.  Although \cxx\ cannot convert
template types with a \texttt{T} to ones with a \texttt{const T}
reference, the rarray library provides this conversion from
\texttt{rarray{\tt<}T,R{\tt>}} to a \texttt{rarray{\tt<}const
  T,R{\tt>}}. For example:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  #include <rarray>
  float add(const rarray<const float,2> &s)   {
     float x = 0.0;
     for (int i=0; i<s.extent(0); i++)
        for (int j=0; j<s.extent(1); j++)
           x += s[i][j];
     return x;
  }
  int main() {
     rarray<float,2> s(40, 40); // note: not const!
     float z = add(s); // yet this works
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}
\end{framed}\vspace{-8pt}
One can also explicitly use the \texttt{const\_ref} method to do this conversion.

Note: This works equally well when the function argument is passed by value.

Rarray objects are also easy to pass to functions from legacy that do
not use \texttt{rarray}s but pointers.  To avoid ambiguities, 
conversions of a rarray to a pointer must be done using
methods.

There are two main ways that such functions expect a multidimensional
array to be passed: either as a pointer (a \texttt{T*}) to the first
element of the internal buffer composed of all elements, or as a
pointer-to-pointer structure (a \texttt{T**...}).  In the former case, it may be
important to know that a rarray stores elements in row-major
format.

With the \texttt{const} keyword, the number of useful \cxx\ forms for multidimensional array arguments has grown to about six.  In the case of a two-dimensional array these take the forms:
 \texttt{T*}, \texttt{const T*}, \texttt{T*const*}, \texttt{const T*const*}, \texttt{T**}, and \texttt{const T**}.
Using the rarray library, const-correct argument passing requires the \texttt{data} or \texttt{ptr\_array} method but non-const-correct argument passing will require the \texttt{noconst\_ptr\_array} function, possibly combined with \texttt{const\_ref}.
We will briefly looking at these cases separately now.

\subsection{Conversion to a {\tt T*} or a {\tt const T*}}

A function may expect a multidimensional array to be passed as a
simple pointer to the first element, of the form \texttt{T*}, or of
the form  \texttt{const T*}. This is the case for most c or fortran
libraries, as disussed above. A rarray object
\texttt{s} of type \texttt{rarray{\tt<}T,I{\tt>}} can be passed to these
functions using the syntax \texttt{s.data()}, which yields a
\texttt{T*}.

\noindent{\bf Example 1:}
\begin{framed}\vspace{-15pt}%
%TEST THIS
\begin{verbatim}
  void fill1(float* a, int n1, int n2, float z) {
     for (int i=0; i<n1*n2; i++)
       a[i] = z;
  }
  int main() {
     rarray<float,2> s(40, 40);
     fill1(s.data(), s.extent(0), s.extent(1), 3.14);
  }
\end{verbatim}%
%END TEST THIS
\end{framed}

\pagebreak[3]

\noindent{\bf Example 2:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  float add2(const float* a, int n1, int n2) {
     float x = 0.0;
     for (int i=0; i<n1*n2; i++)
         x += a[i];
     return x;
  }
  int main() {
     rarray<float,2> s(40, 40);
     float z = add2(s.data(), s.extent(0), s.extent(1));
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}\end{framed}\vspace{-8pt}

\noindent
C++ accepts a \texttt{float*} instead of a \texttt{const float*}, so \texttt{data()} can be used in the latter example.

\subsection{Conversion to a {\tt T*const*} or a {\tt const T*const*} }

\noindent
In \texttt{T*const*}, the middle const means that one cannot reassign
the row pointers. 
The rarray classes can be converted to this type using the
\texttt{ptr\_array()} method.
For higher dimensions, this case generalizes to \texttt{T*const*const*}, \texttt{T*const*const*const*}, etc.

\noindent
{\bf Example 1:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  void fill3(float*const* a, int n1, int n2, float z) {
     for (int i=0; i<n1; i++)
        for (int j=0; j<n2; j++)
           a[i][j] = z;
  }
  int main() {
     rarray<float,2> s(40, 40);
     fill3(s.ptr_array(), s.extent(0), s.extent(1), 3.14);
     // or, since rarray 2.0:
     fill3(s, s.extent(0), s.extent(1), 3.14);
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}\end{framed}\vspace{-8pt}

\noindent
{\bf Example 2:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  float add4(const float*const* a, int n1, int n2) {
     float x = 0.0;
     for (int i=0; i<n1; i++)
        for (int j=0; j<n2; j++)
           x += a[i][j];
     return x;
  }
  int main() {
     rarray<float,2> s(40, 40);
     float z = add4(s.ptr_array(), 40, 40);
     // or,, since rarray 2.0,  z = add4(s, 40, 40);
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}
\end{framed}

\noindent
\cxx\ accepts a \texttt{T*const*} where a \texttt{const T*const*} is expected, so here one can again use the method \texttt{ptr\_array()}.


\subsection{Conversion to a {\tt T**}}

\noindent
If one were to generating a T** from a rarray object, one could change
the internal structure of that rarray object through the double
pointer.  This is therefore considered not ``const-correct''.  It is
however sometimes needed when using legacy code that expects such a
pointer, and for that reason, \texttt{rarray} has a function for it, called \texttt{noconst\_ptr\_array}. 

\noindent
{\bf Example:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  void fill5(float** a, int n1, int n2, float z) {
     for (int i=0; i<n1; i++)
        for (int j=0; j<n2; j++)
           a[i][j] = z;
  }
  int main() {
     rarray<float,2> s(40, 40);
     fill5(s.noconst_ptr_array(), s.extent(0), s.extent(1), 3.14);
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt}
\end{framed}

C++ does not allow conversion from T** to \texttt{const T**}. To convert to a \texttt{const T**}, one first needs to convert the \texttt{rarray{\tt<}T,R{\tt>}} to a \texttt{rarray{\tt<}const T,R{\tt>}} using \texttt{const\_ref()}, after which one can use the \texttt{noconst\_ptr\_array} function.

\noindent
{\bf Example:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
%TEST THIS
\begin{verbatim}
  float add6(const float** a, int n1, int n2) {
     float x = 0.0;
     for (int i=0; i<n1; i++)
        for (int j=0; j<n2; j++)
           x += a[i][j];
     return x;
  }
  int main() {
     rarray<float,2> s(40, 40);
     float z = add6(s.const_ref().noconst_ptr_array(), 40, 40);
  }
\end{verbatim}%
%END TEST THIS
\vspace{-14pt} 
\end{framed}

\pagebreak
\appendix

\section{Installation}

Rarray is a header-only library, so you could just copy the header \texttt{rarray} to the directory \texttt{/usr/include} or some other directory
where your C++ compiler looks for header files.  Alternatively, you could use the command
\begin{verbatim}
    make install PREFIX=[BASEDIR]
\end{verbatim}
This installs the header file in the \texttt{[BASEDIR]/include} directory,
and the documentation in\linebreak \texttt{[BASEDIR]/share/doc}.
If you have sudo permissions, you can also do
\begin{verbatim}
    sudo make install
\end{verbatim}
to install the header and documentation to /usr/include and /usr/share/doc,
respectively. Note that this will fail on recent MacOS versions,
in which case, try \texttt{sudo make install PREFIX=/usr/local}.

To modify rarray, do not edit the rarray header file, as this is a generated file. Instead, you
should edit the files in the \texttt{headersources} directory.  You
can use the included Makefile to assemble the rarray headers with
\begin{verbatim}
    make headers
\end{verbatim}

If you're editing the documentation (this file), you need pdflatex, and you should edit\linebreak \texttt{rarraydoc.tex} and then do
\begin{verbatim}
    make doc
\end{verbatim}

The Makefile can also be used to compile and run the unit tests and benchmarks. Simply do:
\begin{verbatim}
    ./configure
    make test
    make benchmarks
\end{verbatim}
The \texttt{configure} command should work under Linux if you have a recent
GNU, Intel, IBM or Clang compiler.  Note that to pick your compiler,
you may have the set the CXX environment variable point to the right
compiler command (e.g. \texttt{export CXX=clang++}) before running \texttt{configure}.

If the include directory is not in the compiler's search path, you
will need to pass an option to the compiler directing to that
directory (i.e. \texttt{-I[BASEDIR]/include}) or, for gcc, clang and intel compilers,
set the CPATH environment variable.

\newpage

\section{History}

Dec 2013:

First implementation of the header-only library \texttt{rarray} for runtime multidimensional arrays.

\noindent
Jan 2014: Version 1.0

Code put on github

\noindent
Mar 2015: Version 1.1

Changed the text output format used to use newlines

\noindent
Feb 2017: Version 1.2

Added C++11 aliases rvector, rmatrix and rtensor. Eliminated the need
for rarraymacros.h and rarraydelmacros.h in the installed version of
rarray.

\noindent
Oct 2019: Version 2.0

Prompted by a deeply rooted memory leak, this version is a full
rewrite of rarray from the ground up, leaving most of the application
interface unchanged.  Rarray now \textbf{requires} C++11.
The optional but expensive capability to do index range checking has
partially been lost in the rewrite.  Rarray comes with its own unit testing
library now, 'rut'.

\noindent
Jan 2020: Version 2.1

Reference counting of rarray data is now done atomically, so copying
rarrays should now be thread-safe.  One-character names of
substructures, used in debugging rarray itself, were
removed. Streaming operators for rarrays moved to the \texttt{ra}
namespace.

\noindent
Feb 2020: Version 2.2

Several bug fixed with running and installing rarray on MacOS.  The
rarray unit test library 'rut' was dropped in favour of 'catch2',
which does everything that 'rut' was intended to do, but better. Since
'catch2' is header only, this makes running the tests on different
platforms much easier.

\noindent
Jan 2022: Version 2.3

Streaming I/O now part of the rarray header. rarrayio header is
obsolete, but kept for backwards compatibility. 

\noindent
Dec 2022: Version 2.4

Internal refactoring focussed on eliminating warnings, dead code,
version tracking in code, and exception safety.
Fixed bug for compound data types.
Support added for Intel OneAPI's icpx C++ compiler.

\noindent
Dec 2022: Version 2.5

Optional bounds checking is back.\\
\texttt{is\_clear} renamed to \texttt{empty}.\\
Can now get a subarray with square brackets.\\
Rarray objects no no longer automatically convert into T*const*... pointers.\\
More extensive unit and coverage tests.

\noindent
Nov 2023: Version 2.6

Bug fixes (inlining, compiler settings, exception safety).  Better
support for \texttt{rarray<const T,R>}.  Implicit conversion operator
from \texttt{rarray<T,R>} to \texttt{rarray<const T,R>}.  Started
support for the multidimensional subscript operator for C++23 complient compilers.
Code cleanup.

\end{document}
