\documentclass[12pt,twoside]{article}
\usepackage{a4wide,fancyhdr,hyperref,framed}
\setcounter{tocdepth}{1}
\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection\quad #1}}
\fancyhf{}
\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries \hfill\rightmark\hfill}
\fancyhead[RE]{\hfill\bfseries\rightmark \hfill}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{2.5pt}
\fancypagestyle{plain}{\fancyhead{}\renewcommand{\headrulewidth}{0pt}}
\let\oldtt=\tt
%\renewcommand{\texttt}[1]{\color{blue}\tt #1\color{black}}
\newcommand{\cxx}{C{++}}

%\renewcommand{\texttt}[1]{#1}
\begin{document}

\setlength{\parskip}{1mm}

\title{The \texttt{rarray} Library:\\Multidimensional Runtime Arrays for \cxx}

\author{Ramses van Zon\\
\it\small SciNet High Performance Computing Consortium, University
of Toronto, Toronto, Ontario, Canada\vspace{-8pt}} 

\date{\small November 27, 2013\vspace{-5mm}}

\maketitle

\section{Introduction}

While C and thus C++ has some support for multidimensional arrays whose sizes are known at compile time, the support for arrays with sizes that are known only at runtime, is limited. For one-dimensional  arrays,  C++ has a reasonable allocation construction in the operators \texttt{new} and \texttt{delete}. An example of the standard way to allocate a one-dimensional array is the following piece of code:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
float* a;
int n = 1000;
a = new float[n];
a[40] = 2.4;
delete[] a;
\end{verbatim}%
\vspace{-12pt}\end{framed}\vspace{-5pt}%
It is important to note that this code also works if \texttt{n} was not known yet, e.g., if it was passed as a function argument or read in as input. 

In the above code snippet, the new/delete construct assigns the address of the array to a pointer. This pointer does not remember its size, so this is not really an 'array'.  The standard C++ library does provide a one-dimensional array that remembers it size in the form of the \texttt{std::vector}, e.g.
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
std::vector a;
int n = 1000;
a.reserve(n);
a[40] = 2.4;
a.clear();
\end{verbatim}%
\vspace{-12pt}\end{framed}\vspace{-5pt}%

Multi-dimensional runtime-allocated arrays are not supported by \cxx.
The textbook \cxx\ solution for multidimensional arrays that are
dynamically allocated during runtime, is as follows:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  float*** a;
  a = new float**[dim0];
  for (int i=0;i<dim0;i++) {
    a[i] = new float*[dim1];
    for (int j=0;j<dim1;j++) 
      a[i][j] = new float[dim2];
  }
\end{verbatim}%
\vspace{-12pt}\end{framed}\vspace{-5pt}%
Drawbacks of this solution are the non-contiguous buffer for the
elements (so it's unusable for many libraries) and having to keep
track of array dimensions.
%However, with \cxx{} offering the language constructs to create new types, 
At first, there seems to be no shortage of libraries to fill this
lack of \cxx\ support for dynamic multi-dimensional arrays, such as
\begin{itemize}\itemsep 0pt \parskip 0pt
\item Blitz++;
\item The Boost Multidimensional Array Library (\texttt{boost::multiarray}); 
\item Eigen;
\item Armadillo; and
\item Nested \texttt{vector}s from the Standard Template Library.
\end{itemize}
These typically do have some runtime overhead compared to the above
textbook solution. In contrast, the purpose of the rarray
library is to be a minimal interface for runtime multidimensional arrays with
\emph{minimal to no performance overhead} compared to the textbook solution.

\noindent{\bf Example:\vspace{-7pt}}
\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  #include "rarray.h"
  int main() 
  {
     rarray<float,3> a(256, 256, 256);
     a[1][2][3] = 105;
  }
\end{verbatim}%
\vspace{-14pt}%
\end{framed}

\noindent{\bf Features of rarray:\vspace{-3pt}}
\begin{itemize}\itemsep0pt\parskip2pt
\item Can use any data type T and any rank R.
\item Provides views on existing contiguous arrays.
\item Does shallow, reference counted copies by default, but also has a
  deep {\tt copy} method.
\item Elements are accessible using repeated square brackets, like c/c++ arrays.
\item Can be emptied with the {\tt free} method.
\item Can be reshaped.
\item Automatic C-style arrays can be converted to rarrays using RARRAY.
\item Checks index bounds if the preprocessor
  constant {\tt BOUNDSCHECK} is defined. 
\item Provides a method {\tt isfree} to check if the rarray is uninitialized.
\item Provides a method to get the number of elements in each
  dimension (\texttt{extent}), or in all dimensions (\texttt{extents}).
\item Provides  a method to obtain the total number of elements in the
  array (\texttt{size}).
\item Provides a method to make the data type of the array const
  (\texttt{const\_ref}).
\item Provides conversion methods using the member
  function \texttt{data()} for conversions to a \texttt{T*} or
  \texttt{const T*}, using the method \texttt{ptr\_array()} for
  conversions to \texttt{T*const*} or \texttt{const T*const*}, and
  using the method \texttt{noconst\_ptr\_array()} for the conversion to a
  \texttt{T**}.
\end{itemize}

\section{Class definition}

Effectively, the interface part of a rarray object is defined as follows:%
\vspace{-8pt}%
\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  class rarray<T,R> {
   public:    
    rarray<T,R>();                         // create uninitialized array
    rarray<T,R>(int dim0, ...);            // give dimensions for R<7
    rarray<T,R>(const int*dim);            // dimensions in an array
    rarray<T,R>(T* buf, int dim0, ...);    // give dimensions for R<7
    rarray<T,R>(T* buf, const int*dim);    // dimensions in an array
    rarray<T,R>(const rarray<T,R> &a);     // shallow copy constructor   
    rarray<T,R>& operator=(const rarray<T,R> &a); // shallow assignment
    ~rarray<T,R>();                        // destructor 
    void              reshape(int dim0, ...);// change shape (not data)
    void              reshape(const int*dim);// change shape (not data)
    void              free();              // release memory
    bool              isfree();     const; // check if uninitialized;
    rarray<T,R>       copy()        const; // deep copy
    const int*        extents()     const; // size of all dimensions 
    int               extent(int i) const; // size of dimension i
    int               size()        const; // total number of elements
    T*                data()        const; // start of internal buffer
    T*const*...       ptr_array();  const; // convert to a T*const*... 
    T**...            noconst_ptr_array() const; // converts to a T**... 
    rarray<const T,R>&  const_ref()       const; // convert to const elements
    rarray<const T,R-1> operator[](int i) const; // element access
    rarray<T,R-1>       operator[](int i);       // element access
  };
\end{verbatim}
\end{framed}

\section{Using the {\tt rarray}s}

\subsection{Defining a multidimensional rarray}

To use \texttt{rarray}, first include the header file rarray.h:
\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  #include "rarray.h"
\end{verbatim}%
\vspace{-14pt}
\end{framed}
This defines the (template) classes \texttt{rarray{\tt<}T,R{\tt>}}, where
\texttt T is the element type, and \texttt R is the
rank (a positive integer).  Instances can now be
declared as follows:
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  rarray<float,3> s(256,256,256);
  s[1][2][3] = 105;
  // do whatever you need with s
\end{verbatim}%
\vspace{-14pt}
\end{framed}
or, using an external, already allocated buffer, as
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  float* data=new float[256*256*256];  
  rarray<float,3> s(data,256,256,256);
  s[1][2][3] = 105;
  // do whatever you need with s
  delete[] data;
\end{verbatim}%
\vspace{-14pt}
\end{framed}
Without the \texttt{delete[]} statement in the latter example, there would be a memory leak. This reflects that rarray is in this case not responsible
for the content. The data pointer can also be retrieved using
\texttt{s.data()}. 

Even in the former case (\texttt{rarray<float,3> s(256,256,256)}), one can release the memory of this array by calling \texttt{s.free()} before the rarray goes out of scope.

\subsection{Accessing the elements}

The elements of rarray objects are accessed using the repeated square
bracket notation as for automatic \cxx\ arrays (by design). Thus, if \texttt{s} is a \texttt{rarray} of rank \texttt R, the elements are accessed using \texttt{R} times an index of the form \texttt{[n$_i$]}, i.e. \texttt{s[n$_0$][n$_1$]\dots[n$_{\texttt{R}-1}$]}
For example:\vspace{-9pt}
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
  for (int i=0;i<s.extent(0);i++)
    for (int j=0;j<s.extent(1);j++)
      for (int k=0;k<s.extent(2);k++)
        s[i][j][k] = i+j+k;
\end{verbatim}%
\vspace{-12pt}
\end{framed}\vspace{-8pt}\noindent
The \texttt{extent(int)} method used here returns the size of each dimension (counting from 0).

\subsection{Copying and function arguments}

In C, when we copy a variable of a built-in type to a new variable, the new copy is completely independent of the old variable. Likewise, the default way of passing arguments to a function involves a complete copy as well for built-in type.  For C-style arrays, however, only the pointer to the first element gets copied, not the whole array. The latter is called a shallow copy. Rarrays use shallow copies much like pointers, with the additional functionality that memory allocated by the rarray gets released. 

What does this essentially mean? Well:
\begin{enumerate}
\item You can pass rarrays by value to function, which means the as if you were passing a pointer.
\item If you assign one rarray to another, the other simply points to the old one.
\item If you wish to do a deep copy, i.e., create a new array independent of the old array, you need to use the 'copy' method.
\end{enumerate}

\subsection{Reshaping the rarray}

If you want to use the data in an rarray but access it in a different 'shape', there are two possible approaches:
\begin{enumerate}
  \item You create a new rarray with the desired dimensions, but which uses the data from the first rarray. E.g.
\vspace{-9pt}
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
void dump(const rarray<double,3>& r) {
   rarray<double,1> rflat(r.data(), r.size());
   for (int i=0;i<r.size();i++)
       std::cout << rflat[i] << ' ';
  std::cout << std::endl;
}
\end{verbatim}%
\vspace{-12pt}
\end{framed}\vspace{-8pt}
\item You reshape the existing rarray with the desired dimensions. E.g.
\vspace{-9pt}
\begin{framed}\vspace{-18pt}%
\begin{verbatim}
void dump(rarray<double,3>& r) {
   r.reshape(r.data(), 1, 1, r.size());
   for (int i=0;i<r.size();i++)
       std::cout << rflat[0][0][i] << ' ';
  std::cout << std::endl;
}
\end{verbatim}%
\vspace{-12pt}
\end{framed}\vspace{-8pt}
This only works if the new and old shape have the same ranks, as the rank of the rarray is part of its type. 

The example intentionally also has side effects, as the original rarray that was passed to the dump function now has a different shape.  To fix this, one could pass the \texttt{rarray r} by value. This creates a shallow, reference counted copy, so passing it in is not that expensive. Upon reshaping, \texttt{r} gets unlinked from the reference counting, and the effect is the same as if we has created a new \texttt{rarray} with \texttt{r.data()} as the buffer.
\end{enumerate}
In both cases, the total size of the new shape should be less or equal to that of the old shape. 

\subsection{Comparison with standard alternatives}

The more-or-less equivalent automatic array version 
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  float arr[256][256][256]; 
  arr[1][2][3] = 105;
\end{verbatim}
\vspace{-14pt}\end{framed}
\noindent
is a little simpler, but automatic arrays are allocated on the stack,
which is typically of limited size. Another drawback is that this array cannot be passed to functions that do
not hard-code exactly matching dimensions (except for the last
dimensions, which is why one-dimensional arrays work well enough).

Using rarray also has benefits over another common \cxx\ 
solution using the STL:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  #include <vector>
  int main() {
    using std::vector;
    int n = 256;                 // size per dimension
    vector<vector<vector<float> > > v(n);// allocate for top dimension
    for (int i=0;i<n;i++) {
      v[i].reserve(n);           // allocate vectors for middle dimension
      for (int j=0;j<n;j++) 
        v[i][j].reserve(n);      // allocate elements in last dimension
    }
    v[1][2][3] = 105;            // assign to element (for example)
  }
\end{verbatim}
\vspace{-14pt}\end{framed}\vspace{-8pt}
\noindent
which is complicated, is non-contiguous in memory, and likely
slower. 

\subsection{Optional bounds checking}

If the preprocessor constant \texttt{{\tt BOUNDSCHECK}} is defined, an
\texttt{out\_of\_bounds} exception is thrown~if
\begin{itemize}\itemsep0pt\parskip3pt
\item an index is too small or too large;
\item the size of dimension is requested that does not exist (in a call to \texttt{extent(int i)});
\item a constructor is called with a zero pointer for the buffer or for the dimensions array;
\item a constructor is called with too few or too many arguments (for \texttt{R}$<=6$).
\end{itemize}
\texttt{{\tt BOUNDSCHECK}} can be defined by
adding the {\tt -DBOUNDSCHECK} argument to the compilation command, or
by \texttt{{\tt\#define BOUNDSCHECK}} before
the \texttt{{\tt\#include "rarray.h"}} in the source.
%\\
%Regardless of \texttt{{\tt BOUNDSCHECK}}, an exception is raised if the %memory allocation for rarray fails.

%\pagebreak[4]
\subsection{Methods of {\tt rarray}}

%\subsubsection{Get size in each dimension: \tt extent}
\noindent\textbf{Definition:} \texttt{int extent(int i) const;}

This method returns the size of dimension \texttt{i}.

%\subsubsection{Get size in each dimension: \tt extent}
\noindent\textbf{Definition:} \texttt{const int* extents() const;}

This method returns the size of all dimensions as a c array. 

%\subsubsection{Get total size: \tt size}
\noindent\textbf{Definition:} \texttt{int size() const;}

This method returns the total number of elements.

%\subsubsection{Get pointer equivalent: \tt data}

\noindent\textbf{Definition:} \texttt{T* data() const;}

This method returns a pointer to a \texttt{T*}. Const-correct.

%\subsubsection{Get pointer equivalent: \tt ptr\_array}

\noindent\textbf{Definition:} \texttt{T*const*... ptr\_array() const;}

This method returns a pointer to a \texttt{T*const*...}. Const-correct.

%\subsubsection{Get const-casted pointer equivalent: \tt noconst_ptr\_array}

\noindent\textbf{Definition:} \texttt{T**... noconst\_ptr\_array() const;}

This method returns a pointer to a \texttt{T**...}. This conversion breaks const-correctness.%, as the pointer structure itself could in principle be modified.

%\subsubsection{Get const-content equivalent: \tt const\_ref}

\noindent\textbf{Definition:} \texttt{rarray{\tt<}const T,R{\tt>}\& const\_ref() const;}

This method creates reference to this with const elements.

\noindent\textbf{Definition:} \texttt{void reshape(int dim0, ...);}

This method can be used to change the shape of the rarray. The data in the underlying buffer will not change. Note that the number of dimensions must remain the same and the total new size must be less or equal to the old size. If the rarray was a reference to another rarray, the reference will get destroyed even though the data is still shared.

\noindent\textbf{Definition:} \texttt{void reshape(const int*dim);}

Same as the previous reshape method, but takes an array of new dimensions as an argument.  This is the only way to reshape an array of rank seven or higher.

\noindent\textbf{Definition:} \texttt{void free();}

This method release memory the memory associated with the rarray. If the rarray was created by providing a pre-existing buffer for the data, the memory of this buffer does not released.

\noindent\textbf{Definition:} \texttt{bool isfree();}

Checks if the rarray is in an uninitialized state.

\noindent\textbf{Definition:} \texttt{rarray{\tt<}T,R{\tt>}\& copy() const;}

This method creates deep copy of the rarray.


\section{Conversion of automatic C-style arrays to rarrays}

It is possible to convert C-style automatic arrays to rarrays using the {\tt RARRAY} macro (which calls some templated functions under the hood).  You can apply RARRAY to any automatic array of rank six or less, and even to a rarray (which essentially does nothing). 

The main convenience of this is that one can write functions that take rarray argument(s) and pass automatic arrays to them. Another use is in initializing a rarray;

Examples:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
#include <iostream>
#include "rarray.h"

void print2d(const rarray<float,2> &s) 
{
    for (int i=0; i<s.extent(0); i++) {
        for (int j=0; j<s.extent(1); j++)
            std::cout << s[i][j] << ' ';
        std::cout << std::endl;
    }
}

int main() 
{
    float printme[4][4] = { { 1.0, 1.2, 1.4, 1.6},
                            { 2.0, 2.2, 2.4, 2.6},
                            { 3.0, 3.2, 3.4, 3.6},
                            { 4.0, 4.2, 4.4, 4.6} };
    print2d(RARRAY(printme));
    rarray<float,2> a = RARRAY(printme).copy();
    print2d(a);
}
\end{verbatim}
\vspace{-14pt}\end{framed}\vspace{-8pt}



\section{Conversion of rarray objects and function arguments}

If rarray objects are to be passed to functions, it may be good idea to have the function take (const) references to the rarray. Otherwise, the \texttt{rarray} will be shallowly copied (which really isn't all that expensive).  For example:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  void fill(const rarray<float,2> &s, float z) 
  {
     for (int i=0; i<s.extent(0); i++)
        for (int j=0; j<s.extent(1); j++)
           s[i][j] = z;
  }

  int main() 
  {
    rarray<float,2> s(new float[40*40], 40, 40);
    fill(s, 3.14);
    delete[] s.data();
  }
\end{verbatim}
\vspace{-14pt}\end{framed}\vspace{-8pt}

A function might take a \texttt{rarray{\tt<}const T,R{\tt>}} parameter if elements are not changed by it. Because \cxx\ cannot convert a reference to a \texttt{rarray{\tt<}T,R{\tt>}} to a \texttt{rarray{\tt<}const T,R{\tt>}}, one has to use the \texttt{cons\_ref} method.
For example:
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  float add(const rarray<const float,2> &s) 
  {
     float x = 0.0;
     for (int i=0; i<s.extent(0); i++)
        for (int j=0; j<s.extent(1); j++)
           x += a[i][j];
     return x;
  }
  int main() 
  {
    rarray<float,2> s(new float[40*40], 40, 40);
    float z = add(s.const_ref()); // const_ref() because add() takes <const float>
    delete[] s.data();
  }
\end{verbatim}
\vspace{-14pt}
\end{framed}\vspace{-8pt}

rarray objects are also easy to pass to function that do not use \texttt{rarray}s. Because there are, by design, no automatic conversions of a
rarray, this is done using methods.

There are two main ways that such functions expect a multidimensional
array to be passed: either as a pointer (a \texttt{T*}) to the first
element of the internal buffer composed of all elements, or as a
pointer-to-pointer structure (a \texttt{T**...}).  The latter case
will be mostly for C based libraries.  In the former case, it may be
important to know that a rarray accesses elements in row-major
format.

With the \texttt{const} keyword, the number of useful \cxx\ forms for multidimensional array arguments has grown to about six.  In the case of a two-dimensional array these take the forms:
 \texttt{T*}, \texttt{const T*}, \texttt{T*const*}, \texttt{const T*const*}, \texttt{T**}, and \texttt{const T**}.
Using the rarray library, const-correct argument passing requires the \texttt{data} or \texttt{ptr\_array} method but non-const-correct argument passing will require the \texttt{noconst\_ptr\_array} function, possibly combined with \texttt{const\_ref}.
We will briefly looking at these cases separately now.
%  Each will be started with a simple example, followed by an explanation.

\subsection{Conversion to a {\tt T*} or a {\tt const T*}}

A function may expect a multidimensional array to be passed as a
simple pointer to the first element, of the form \texttt{T*}, or of the form  \texttt{const T*}. A rarray object
\texttt{s} of type \texttt{rarray{\tt<}T,I{\tt>}} can be passed to these
functions using the syntax \texttt{s.data()}, which yields a
\texttt{T*}.

\noindent{\bf Example 1:}
\begin{framed}\vspace{-9pt}%
\begin{verbatim}
  void fill1(float* a, int n1, int n2, float z) {
     for (int i=0; i<n1*n2; i++)
       a[i] = z;
  }
  int main() {
    rarray<float,2> s(new float[40*40], 40, 40);
    fill1(s.data(), s.extent(0), s.extent(1), 3.14);
    delete[] s.data();
  }
\end{verbatim}
\end{framed}

\noindent{\bf Example 2:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  float add2(const float* a, int n1, int n2) {
     float x = 0.0;
     for (int i=0; i<n1*n2; i++)
         x += s[i];
     return x;
  }
  int main() {
     rarray<float,2> s(new float[40*40], 40, 40);
     float z = add2(s.data(), s.extent(0), s.extent(1));
     delete[] s.data();
  }
\end{verbatim}
\vspace{-14pt}\end{framed}\vspace{-8pt}

\noindent
C++ accepts a \texttt{float*} instead of a \texttt{const float*}, so \texttt{data()} can be used in the latter example.

\subsection{Conversion to a {\tt T*const*} or a {\tt const T*const*} }

\noindent
In \texttt{T*const*}, the middle const means that one cannot reassign the row pointers.
The rarray classes can be converted to this type using the \texttt{ptr\_array()} method. 
For higher dimensions, this case generalizes to \texttt{T*const*const*}, \texttt{T*const*const*const*}, etc.

\noindent
{\bf Example 1:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  void fill3(float*const* a, int n1, int n2, float z) {
     for (int i=0; i<n1; i++)
        for (int j=0; j<n2; j++)
           a[i][j] = z;
  }
  int main() {
    rarray<float,2> s(new float[40*40], 40, 40);
    fill3(s.ptr_array(), s.extent(0), s.extent(1), 3.14);
    delete[] s.data();
  }
\end{verbatim}
\vspace{-14pt}\end{framed}\vspace{-8pt}

\noindent
{\bf Example 2:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  float add4(const float*const* a, int n1, int n2) {
     float x = 0.0;
     for (int i=0; i<n1; i++)
        for (int j=0; j<n2; j++)
           x += s[i][j];
     return x;
  }
  int main() {
    rarray<float,2> s(new float[40*40], 40, 40);
    float z = add4(s.ptr_array());
    delete[] s.data();
  }
\end{verbatim}\vspace{-14pt}
\end{framed}

\noindent
\cxx\ accepts a \texttt{T*const*} where a \texttt{const T*const*} is expected, so here one can again use the method \texttt{ptr\_array()}.
This extends to its generalizations \texttt{const T*const*const*}, \texttt{const T*const*const*const*}, etc., as well.


\subsection{Conversion to a {\tt T**}}

\noindent
Generating a T** from a rarray object, one could change the internal structure of that rarray object through the double pointer.  This is therefore considered a not const-correct.  It is however commonly needed, so \texttt{rarray} does have a function for it, called \texttt{noconst\_ptr\_array}. 

\noindent
{\bf Example:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  void fill5(float** a, int n1, int n2, float z) {
     for (int i=0; i<n1; i++)
        for (int j=0; j<n2; j++)
           a[i][j] = z;
  }
  int main() {
    rarray<float,2> s(new float[40*40], 40, 40);
    fill5(s.noconst_ptr_array(), s.extent(0), s.extent(1), 3.14);
    delete[] s.data();
  }
\end{verbatim}\vspace{-14pt}
\end{framed}

\subsection{Conversion to a {\tt const T**}}
\noindent
C++ does not allow conversion from T** to \texttt{const T**}. To convert to a \texttt{const T**}, one first needs to convert the \texttt{rarray{\tt<}T,R{\tt>}} to a \texttt{rarray{\tt<}const T,R{\tt>}} using \texttt{const\_ref()}, after which one can use the \texttt{noconst\_ptr\_array} function.

\noindent
{\bf Example:}
\vspace{-5pt}\begin{framed}\vspace{-14pt}%
\begin{verbatim}
  float add6(const float** a, int n1, int n2) {
     float x = 0.0;
     for (int i=0; i<n1; i++)
        for (int j=0; j<n2; j++)
           x += s[i][j];
     return x;
  }
  int main() {
    rarray<float,2> s(new float[40*40], 40, 40);
    float z = add6(s.const_ref().noconst_ptr_array());
    delete[] s.data();
  }
\end{verbatim}\vspace{-14pt}
\end{framed}

\section{Overheads}

\subsection{Memory overhead using the rarray class}

The memory overhead here comes from having to store the dimensions and a pointer-to-pointer structure.  The latter account for most of the memory overhead.   A rarray object of 100$\times$100$\times$100$\times$100  doubles on a 64-bit machine will have a memory overhead of a bit over 1\%. In general, the memory overhead as a percentage is roughly 100\% divided by the last dimension. Therefore, avoid rarrays with a small last dimension such as 100$\times$100$\times$100$\times$2.

\subsection{Performance overhead using the rarray class}

When compiled with optimization on (\texttt{-O3 -fstrict-aliasing} is a good default), inlining should make the rarray objects at least as fast as the textbook solution above. %\footnote{Tested with gcc 4.6.1 - 4.8.2 and, icc 12.1.5 on x86, and with xlC 12.1 on power 6.}
So in that sense, no there is no performance overhead.  
However, with \texttt{{\tt BOUNDSCHECK}} defined, one incurs a compiler and machine dependent performance hit.


\subsection{Compilation overhead using the rarray class}

There is an overhead in the compilation stage, but this is very compiler dependent.


\end{document}
